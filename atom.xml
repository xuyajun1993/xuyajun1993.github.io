<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>西西弗的神话</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xuyajun.cn/"/>
  <updated>2017-05-28T12:55:45.000Z</updated>
  <id>http://xuyajun.cn/</id>
  
  <author>
    <name>yajun xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring-aop</title>
    <link href="http://xuyajun.cn/2017/05/28/Spring-aop/"/>
    <id>http://xuyajun.cn/2017/05/28/Spring-aop/</id>
    <published>2017-05-28T12:45:46.000Z</published>
    <updated>2017-05-28T12:55:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>端午节假期的第一天，一大早决定好接下来三天的菜谱，列个菜单，去超市屯了三天的食粮。中午要好好犒劳自己，按照和👶的新约定，今晚10点前要写出一篇有质量的博文，不然就要给👶发红包。本想发红包了事，假期第一天还是想舒舒服服的玩玩游戏，看看奇葩说，追追剧啥的。然刚好这期奇葩说激辩无上进心是否是错。得嘞，我错了，背上刚买的小背包，踏上图书馆之旅。。。<br><a id="more"></a></p>
<p>今天来看下 AOP 吧，虽然 Java 也接触了三年了，但似乎一直忽略了 AOP。切面，通知这些基本要素也都忘的差不多了。今天来更深刻的认识一下吧。</p>
<h2 id="术语重温"><a href="#术语重温" class="headerlink" title="术语重温"></a>术语重温</h2><p>先来通过<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#aop" target="_blank" rel="external">官方文档</a>重温一下几个 AOP 术语：</p>
<ol>
<li>切面（Aspect）：一个横向逻辑的模块，它会包括切入点，通知等下面的术语。</li>
<li>连接点（Join point）：程序执行期间的一个点,如一个方法的执行或异常的处理。在Spring AOP,连接点总是代表一个方法执行。</li>
<li>通知（Advice）：切面在某个具体的连接点采取的行为或行动，称为通知。分为前置通知，返回通知，异常通知，后置通知，环绕通知。</li>
<li>切入点（Pointcut）：要织入通知的所有连接点的集合。</li>
<li>引入（Introduction）：通过引入，我们可以在一个对象中加入新的方法和属性，而不用修改它的程序，即在执行时期动态加入一些方法或行为。</li>
<li>目标对象（Target object）：被一个或者多个切面通知的对象。因为 Spring AOP 是通过运行时代理实现的，这个对象永远是一个被代理对象。</li>
<li>代理（AOP proxy）：由 AOP 框架创建的对象，用来实现切面契约（包括通知方法执行等功能）。 在 Spring 中，AOP 代理可以是 JDK 动态代理或者 CGLIB 代理。</li>
<li>织入（Weaving）：把切面连接到其它对象上，并创建一个被通知的对象，这样的行为就叫做织入。可以在编译时（使用 AspectJ），类加载时和运行时完成。 Spring 和其他纯 Java AOP 框架一样，在运行时完成织入 。</li>
</ol>
<p>确实，这些术语不太直观，需要仔细推敲加上代码 demo 才能理解。要想 once for all ，还是得粗暴的进入源码。来，一起。</p>
<h2 id="源码窥探"><a href="#源码窥探" class="headerlink" title="源码窥探"></a>源码窥探</h2><p>从哪看起呢，之前都是自己肉眼先扫描下每个类，来强行梳理出一个逻辑。但 AOP 作为一个单独的模块，那么多个 class 文件，还这样做，未免太低效。差点忘记有《 spring 源码深度解析》这本书，学习下作者的思路。来，以 \<aop:aspectj-autoproxy> 这句配置作为入口。<br>全局搜索下 aspectj-autoproxy ，找到这个配置的解析器。不难发现 AopNamespaceHandler 这个类。看这行代码继续溯源：</aop:aspectj-autoproxy></p>
<blockquote>
<pre><code>registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser());
</code></pre></blockquote>
<p>OK，先来分析 AspectJAutoProxyBeanDefinitionParser 这个类做了些什么。</p>
<h3 id="AspectJAutoProxyBeanDefinitionParser"><a href="#AspectJAutoProxyBeanDefinitionParser" class="headerlink" title="AspectJAutoProxyBeanDefinitionParser"></a>AspectJAutoProxyBeanDefinitionParser</h3><p>所有解析器都实现了 BeanDefinitionParser 接口，入口方法parser() ，而该方法继续调用了 registerAspectJAnnotationAutoProxyCreatorIfNecessary（）方法，贴下这个方法：</p>
<pre><code>public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(
        ParserContext parserContext, Element sourceElement) {

    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(
            parserContext.getRegistry(), parserContext.extractSource(sourceElement));
    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
    registerComponentIfNecessary(beanDefinition, parserContext);
}
</code></pre><p>一共三行，每行都是一个逻辑。</p>
<ol>
<li><p>注册或者升级 AnnotationAwareAspectJAutoProxyCreator</p>
<p> 继续贴下一步的代码  </p>
<pre><code>public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) {
    return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
}

private static BeanDefinition registerOrEscalateApcAsRequired(Class cls, BeanDefinitionRegistry registry, Object source) {
    Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);
    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
    BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
    if (!cls.getName().equals(apcDefinition.getBeanClassName())) {
        int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
        int requiredPriority = findPriorityForClass(cls);
        if (currentPriority &lt; requiredPriority) {
            apcDefinition.setBeanClassName(cls.getName());
        }
    }
    return null;
    }
    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);
    beanDefinition.setSource(source);
    beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);
    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
    return beanDefinition;
}
</code></pre></li>
</ol>
<pre><code>如果已经有了自动代理创建器，则选择优先级高的创建器。至于这个自动代理创建器，在温习几个术语的时候已经知道，要想对一个类进行功能增强，需要创建一个代理类。有意思的是，因为 spring 本身就是基于代理的系统，所以 AOP 的功能就是代理中的代理去创建类。。。
</code></pre><ol>
<li><p>处理 proxy-target-class 和 expose-proxy 属性</p>
<pre><code>private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) {
    if (sourceElement != null) {
        boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));
        if (proxyTargetClass) {
            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
        }
        boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));
        if (exposeProxy) {
            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
        }
    }
}
</code></pre><p> 如果 proxy-target-class 设置为 true，则强制使用 cglib 代理。如果 expose-proxy 设置为 true，则支持目标对象内部的自我方法调用也能增强。（上面说了，类功能的增强是通过代理类，但是如果调用内部的方法，则走的不是代理，造成方法增强失效！这块可以看官方文档中关于 AOP 代理这一小节） </p>
</li>
<li><p>注册组建通知（具体不详究）</p>
</li>
</ol>
<h3 id="AspectJAwareAdvisorAutoProxyCreator"><a href="#AspectJAwareAdvisorAutoProxyCreator" class="headerlink" title="AspectJAwareAdvisorAutoProxyCreator"></a>AspectJAwareAdvisorAutoProxyCreator</h3><p>上面说到打开了 AOP 配置的开关后，第一件事就是创建自动代理创建器。下面就来看看这个创建器是怎么扫描 aop 注解并创建代理增强类的功能的（高能预警，下面是一段漫长的追寻之路）。<br>AspectJAwareAdvisorAutoProxyCreator 继承了 BeanPostProcessor，所以以 postProcessAfterInitialization 这个方法为入口。</p>
<pre><code>public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if (bean != null) {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        if (!this.earlyProxyReferences.containsKey(cacheKey)) {
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}
</code></pre><p>如果没有封装过，则封装这个 bean。</p>
<pre><code>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
    if (beanName != null &amp;&amp; this.targetSourcedBeans.containsKey(beanName)) {
        return bean;
    }
    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
        return bean;
    }
    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
        this.advisedBeans.put(cacheKey, Boolean.FALSE);
        return bean;
    }

    // Create proxy if we have advice.
    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
    if (specificInterceptors != DO_NOT_PROXY) {
        this.advisedBeans.put(cacheKey, Boolean.TRUE);
        Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
        this.proxyTypes.put(cacheKey, proxy.getClass());
        return proxy;
    }

    this.advisedBeans.put(cacheKey, Boolean.FALSE);
    return bean;
}
</code></pre><p>如果不是 AOP 的基础类，则予以代理。似乎到此结束，毕竟看到了为需要的方法创建代理我们就放心了。别急，重点在于怎么获取需要增强的方法。</p>
<pre><code>protected Object[] getAdvicesAndAdvisorsForBean(Class beanClass, String beanName, TargetSource targetSource) {
    List advisors = findEligibleAdvisors(beanClass, beanName);
    if (advisors.isEmpty()) {
        return DO_NOT_PROXY;
    }
    return advisors.toArray();
}
</code></pre><p>继续追 findEligibleAdvisors（）。</p>
<pre><code>protected List&lt;Advisor&gt; findEligibleAdvisors(Class beanClass, String beanName) {
    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();
    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
    extendAdvisors(eligibleAdvisors);
    if (!eligibleAdvisors.isEmpty()) {
        eligibleAdvisors = sortAdvisors(eligibleAdvisors);
    }
    return eligibleAdvisors;
}
</code></pre><ol>
<li><p>首先获取候选的增强器</p>
<pre><code>public List&lt;Advisor&gt; findAdvisorBeans() {
    // Determine list of advisor bean names, if not cached already.
    String[] advisorNames = null;
    synchronized (this) {
        advisorNames = this.cachedAdvisorBeanNames;
        if (advisorNames == null) {
            // Do not initialize FactoryBeans here: We need to leave all regular beans
            // uninitialized to let the auto-proxy creator apply to them!
            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
                    this.beanFactory, Advisor.class, true, false);
            this.cachedAdvisorBeanNames = advisorNames;
        }
    }
    if (advisorNames.length == 0) {
        return new LinkedList&lt;Advisor&gt;();
    }

    List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;();
    for (String name : advisorNames) {
        if (isEligibleBean(name)) {
            if (this.beanFactory.isCurrentlyInCreation(name)) {
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;Skipping currently created advisor &apos;&quot; + name + &quot;&apos;&quot;);
                }
            }
            else {
                try {
                    advisors.add(this.beanFactory.getBean(name, Advisor.class));
                }
                catch (BeanCreationException ex) {
                    Throwable rootCause = ex.getMostSpecificCause();
                    if (rootCause instanceof BeanCurrentlyInCreationException) {
                        BeanCreationException bce = (BeanCreationException) rootCause;
                        if (this.beanFactory.isCurrentlyInCreation(bce.getBeanName())) {
                            if (logger.isDebugEnabled()) {
                                logger.debug(&quot;Skipping advisor &apos;&quot; + name +
                                        &quot;&apos; with dependency on currently created bean: &quot; + ex.getMessage());
                            }
                            // Ignore: indicates a reference back to the bean we&apos;re trying to advise.
                            // We want to find advisors other than the currently created bean itself.
                            continue;
                        }
                    }
                    throw ex;
                }
            }
        }
    }
    return advisors;
}
</code></pre></li>
<li><p>筛选出适用于 bean 的增强器</p>
<pre><code>public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) {
    if (candidateAdvisors.isEmpty()) {
        return candidateAdvisors;
    }
    List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;Advisor&gt;();
    for (Advisor candidate : candidateAdvisors) {
        if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) {
            eligibleAdvisors.add(candidate);
        }
    }
    boolean hasIntroductions = !eligibleAdvisors.isEmpty();
    for (Advisor candidate : candidateAdvisors) {
        if (candidate instanceof IntroductionAdvisor) {
            // already processed
            continue;
        }
        if (canApply(candidate, clazz, hasIntroductions)) {
            eligibleAdvisors.add(candidate);
        }
    }
    return eligibleAdvisors;
}
</code></pre><p> 首先处理引入增强，然后处理其他的。最终的匹配在下面方法中处理。</p>
<pre><code>    public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) {
    Assert.notNull(pc, &quot;Pointcut must not be null&quot;);
    if (!pc.getClassFilter().matches(targetClass)) {
        return false;
    }

    MethodMatcher methodMatcher = pc.getMethodMatcher();
    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
    if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
    }

    Set&lt;Class&gt; classes = new LinkedHashSet&lt;Class&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));
    classes.add(targetClass);
    for (Class&lt;?&gt; clazz : classes) {
        Method[] methods = clazz.getMethods();
        for (Method method : methods) {
            if ((introductionAwareMethodMatcher != null &amp;&amp;
                    introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||
                    methodMatcher.matches(method, targetClass)) {
                return true;
            }
        }
    }

    return false;
}
</code></pre></li>
<li><p>创建代理</p>
<pre><code>protected Object createProxy(
        Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {

    ProxyFactory proxyFactory = new ProxyFactory();
    // Copy our properties (proxyTargetClass etc) inherited from ProxyConfig.
    proxyFactory.copyFrom(this);

    if (!shouldProxyTargetClass(beanClass, beanName)) {
        // Must allow for introductions; can&apos;t just set interfaces to
        // the target&apos;s interfaces only.
        Class&lt;?&gt;[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, this.proxyClassLoader);
        for (Class&lt;?&gt; targetInterface : targetInterfaces) {
            proxyFactory.addInterface(targetInterface);
        }
    }

    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    for (Advisor advisor : advisors) {
        proxyFactory.addAdvisor(advisor);
    }

    proxyFactory.setTargetSource(targetSource);
    customizeProxyFactory(proxyFactory);

    proxyFactory.setFrozen(this.freezeProxy);
    if (advisorsPreFiltered()) {
        proxyFactory.setPreFiltered(true);
    }

    return proxyFactory.getProxy(this.proxyClassLoader);
}
</code></pre><p> 到这里似乎有点熟悉的代理代码的影子了。</p>
<ul>
<li>添加当前类的属性</li>
<li>扫描类的所有接口，添加进代理</li>
<li>封装增强器加入代理</li>
<li>设置要代理的类</li>
<li>定制化</li>
<li><p>返回代理类</p>
<p>在最后一步返回代理类，会首先判断选择代理方式，有两种实现，分别是 jdk 动态代理或者 cglib。直接把代理贴出来吧：</p>
<p>  public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {</p>
<pre><code>    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
        Class targetClass = config.getTargetClass();
        if (targetClass == null) {
            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                    &quot;Either an interface or a target is required for proxy creation.&quot;);
        }
        if (targetClass.isInterface()) {
            return new JdkDynamicAopProxy(config);
        }
        return CglibProxyFactory.createCglibProxy(config);
    }
    else {
        return new JdkDynamicAopProxy(config);
    }
}
</code></pre></li>
</ul>
<p>jdk 动态代理创建对象的实现：</p>
<pre><code> public Object getProxy(ClassLoader classLoader) {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());
    }
    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);
    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}
</code></pre><p> cglib 代理创建对象的实现：</p>
<pre><code>public Object getProxy(ClassLoader classLoader) {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource());
    }

    try {
        Class&lt;?&gt; rootClass = this.advised.getTargetClass();
        Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);

        Class&lt;?&gt; proxySuperClass = rootClass;
        if (ClassUtils.isCglibProxyClass(rootClass)) {
            proxySuperClass = rootClass.getSuperclass();
            Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();
            for (Class&lt;?&gt; additionalInterface : additionalInterfaces) {
                this.advised.addInterface(additionalInterface);
            }
        }

        // Validate the class, writing log messages as necessary.
        validateClassIfNecessary(proxySuperClass);

        // Configure CGLIB Enhancer...
        Enhancer enhancer = createEnhancer();
        if (classLoader != null) {
            enhancer.setClassLoader(classLoader);
            if (classLoader instanceof SmartClassLoader &amp;&amp;
                    ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
                enhancer.setUseCache(false);
            }
        }
        enhancer.setSuperclass(proxySuperClass);
        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
        enhancer.setStrategy(new MemorySafeUndeclaredThrowableStrategy(UndeclaredThrowableException.class));
        enhancer.setInterceptDuringConstruction(false);

        Callback[] callbacks = getCallbacks(rootClass);
        Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length];
        for (int x = 0; x &lt; types.length; x++) {
            types[x] = callbacks[x].getClass();
        }
        enhancer.setCallbackFilter(new ProxyCallbackFilter(
                this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
        enhancer.setCallbackTypes(types);
        enhancer.setCallbacks(callbacks);

        // Generate the proxy class and create a proxy instance.
        Object proxy;
        if (this.constructorArgs != null) {
            proxy = enhancer.create(this.constructorArgTypes, this.constructorArgs);
        }
        else {
            proxy = enhancer.create();
        }

        return proxy;
    }
    catch (CodeGenerationException ex) {
        throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; +
                this.advised.getTargetClass() + &quot;]: &quot; +
                &quot;Common causes of this problem include using a final class or a non-visible class&quot;,
                ex);
    }
    catch (IllegalArgumentException ex) {
        throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; +
                this.advised.getTargetClass() + &quot;]: &quot; +
                &quot;Common causes of this problem include using a final class or a non-visible class&quot;,
                ex);
    }
    catch (Exception ex) {
        // TargetSource.getTarget() failed
        throw new AopConfigException(&quot;Unexpected AOP exception&quot;, ex);
    }
}
</code></pre></li>
</ol>
<p>不知不觉已到傍晚，跟着书走了一遍源码，然而还是很吃力，一些细节还是不能准确分析。当然，也没必要深究到每一行代码，aop 的构成，代理的选择等主干路走过就行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;端午节假期的第一天，一大早决定好接下来三天的菜谱，列个菜单，去超市屯了三天的食粮。中午要好好犒劳自己，按照和👶的新约定，今晚10点前要写出一篇有质量的博文，不然就要给👶发红包。本想发红包了事，假期第一天还是想舒舒服服的玩玩游戏，看看奇葩说，追追剧啥的。然刚好这期奇葩说激辩无上进心是否是错。得嘞，我错了，背上刚买的小背包，踏上图书馆之旅。。。&lt;br&gt;
    
    </summary>
    
      <category term="Spring源码" scheme="http://xuyajun.cn/categories/Spring%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-context（schedule）</title>
    <link href="http://xuyajun.cn/2017/05/16/Spring-context%EF%BC%88schedule%EF%BC%89/"/>
    <id>http://xuyajun.cn/2017/05/16/Spring-context（schedule）/</id>
    <published>2017-05-16T15:19:02.000Z</published>
    <updated>2017-05-21T07:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>schedule task 在工作场景中应该是需要频繁使用的。实现方式也很多，常见的当属 spring 自带的注解实现以及 quartz 框架。至于底层原理，使用线程池必不可少。今天就来揭开 spring 是如何对任务调度进行抽象。 <a id="more"></a><br>为了加快理解源码的速度，先浏览下 schedule 模块的<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#scheduling" target="_blank" rel="external">官方文档</a>。看完该模块的 overview 后会发现，设计的思想与缓存如出一辙。就连 package 都基本类似：<br><img src="/images/schedule.png" alt="alt text">  </p>
<h2 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h2><p>Trigger 负责根据上次执行结果来决定下次执行时间，故接口只有一个方法： </p>
<pre><code>Date nextExecutionTime(TriggerContext triggerContext);
</code></pre><p>TriggerContext 也是一个接口，封装了上次执行的结果信息：</p>
<pre><code>Date lastScheduledExecutionTime();//上次计划执行时间
Date lastActualExecutionTime();//上次实际执行时间
Date lastCompletionTime();//上次完成时间
</code></pre><p>trigger 有两个子类，CronTrigger 和 PeriodicTrigger。先来看 CronTrigger。  </p>
<h3 id="CronTrigger"><a href="#CronTrigger" class="headerlink" title="CronTrigger"></a>CronTrigger</h3><p>CronTrigger 基于 cron 表达式来调度任务。</p>
<pre><code>private final CronSequenceGenerator sequenceGenerator;

public Date nextExecutionTime(TriggerContext triggerContext) {
        Date date = triggerContext.lastCompletionTime();
        if (date != null) {
            Date scheduled = triggerContext.lastScheduledExecutionTime();
            if (scheduled != null &amp;&amp; date.before(scheduled)) {
                // Previous task apparently executed too early...
                // Let&apos;s simply use the last calculated execution time then,
                // in order to prevent accidental re-fires in the same second.
                date = scheduled;
            }
        }
        else {
            date = new Date();
        }
        return this.sequenceGenerator.next(date);
    }
</code></pre><p>很显然，CronSequenceGenerator 这个类负责解析 cron 表达式及确定下次执行时间。 让我们偏离主道，看下这个类，很涨姿势。</p>
<h4 id="CronSequenceGenerator"><a href="#CronSequenceGenerator" class="headerlink" title="CronSequenceGenerator"></a>CronSequenceGenerator</h4><p>先看看 “0 0 \<em> \</em> \<em> \</em>” 这种表达式是如何被解析</p>
<pre><code>private void parse(String expression) throws IllegalArgumentException {
    String[] fields = StringUtils.tokenizeToStringArray(expression, &quot; &quot;);
    if (fields.length != 6) {
        throw new IllegalArgumentException(String.format(
                &quot;Cron expression must consist of 6 fields (found %d in \&quot;%s\&quot;)&quot;, fields.length, expression));
    }
    setNumberHits(this.seconds, fields[0], 0, 60);
    setNumberHits(this.minutes, fields[1], 0, 60);
    setNumberHits(this.hours, fields[2], 0, 24);
    setDaysOfMonth(this.daysOfMonth, fields[3]);
    setMonths(this.months, fields[4]);
    setDays(this.daysOfWeek, replaceOrdinals(fields[5], &quot;SUN,MON,TUE,WED,THU,FRI,SAT&quot;), 8);
    if (this.daysOfWeek.get(7)) {
        // Sunday can be represented as 0 or 7
        this.daysOfWeek.set(0);
        this.daysOfWeek.clear(7);
    }
}
</code></pre><p>该类使用了 BitSet 来存储秒，分钟，小时（大家都知道存储大数据量时可以使用 bit-map 算法，没想到 java 实现了），继续进入 setNumberHits 方法。</p>
<pre><code>private void setNumberHits(BitSet bits, String value, int min, int max) {
    String[] fields = StringUtils.delimitedListToStringArray(value, &quot;,&quot;);
    for (String field : fields) {
        if (!field.contains(&quot;/&quot;)) {
            // Not an incrementer so it must be a range (possibly empty)
            int[] range = getRange(field, min, max);
            bits.set(range[0], range[1] + 1);
        }
        else {
            String[] split = StringUtils.delimitedListToStringArray(field, &quot;/&quot;);
            if (split.length &gt; 2) {
                throw new IllegalArgumentException(&quot;Incrementer has more than two fields: &apos;&quot; +
                        field + &quot;&apos; in expression \&quot;&quot; + this.expression + &quot;\&quot;&quot;);
            }
            int[] range = getRange(split[0], min, max);
            if (!split[0].contains(&quot;-&quot;)) {
                range[1] = max - 1;
            }
            int delta = Integer.valueOf(split[1]);
            if (delta &lt;= 0) {
                throw new IllegalArgumentException(&quot;Incrementer delta must be 1 or higher: &apos;&quot; +
                        field + &quot;&apos; in expression \&quot;&quot; + this.expression + &quot;\&quot;&quot;);
            }
            for (int i = range[0]; i &lt;= range[1]; i += delta) {
                bits.set(i);
            }
        }
    }
}
</code></pre><p>该方法是根据表达式，来标记被命中的秒／分／时，即将对应的 bit 设置为 true：</p>
<pre><code>bits.set(i);
</code></pre><p>要理解这个方法需要对 cron 表达式的语法有一定了解。这里不做细叙，迅速看完该类，回到主道。<br>知道了是怎么标识”秒，分，时，日，月，星期，年“计算下一个时间点就好办了。</p>
<pre><code>private void doNext(Calendar calendar, int dot) {
    List&lt;Integer&gt; resets = new ArrayList&lt;Integer&gt;();

    int second = calendar.get(Calendar.SECOND);
    List&lt;Integer&gt; emptyList = Collections.emptyList();
    int updateSecond = findNext(this.seconds, second, calendar, Calendar.SECOND, Calendar.MINUTE, emptyList);
    if (second == updateSecond) {
        resets.add(Calendar.SECOND);
    }

    int minute = calendar.get(Calendar.MINUTE);
    int updateMinute = findNext(this.minutes, minute, calendar, Calendar.MINUTE, Calendar.HOUR_OF_DAY, resets);
    if (minute == updateMinute) {
        resets.add(Calendar.MINUTE);
    }
    else {
        doNext(calendar, dot);
    }

    int hour = calendar.get(Calendar.HOUR_OF_DAY);
    int updateHour = findNext(this.hours, hour, calendar, Calendar.HOUR_OF_DAY, Calendar.DAY_OF_WEEK, resets);
    if (hour == updateHour) {
        resets.add(Calendar.HOUR_OF_DAY);
    }
    else {
        doNext(calendar, dot);
    }

    int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
    int dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH);
    int updateDayOfMonth = findNextDay(calendar, this.daysOfMonth, dayOfMonth, daysOfWeek, dayOfWeek, resets);
    if (dayOfMonth == updateDayOfMonth) {
        resets.add(Calendar.DAY_OF_MONTH);
    }
    else {
        doNext(calendar, dot);
    }

    int month = calendar.get(Calendar.MONTH);
    int updateMonth = findNext(this.months, month, calendar, Calendar.MONTH, Calendar.YEAR, resets);
    if (month != updateMonth) {
        if (calendar.get(Calendar.YEAR) - dot &gt; 4) {
            throw new IllegalArgumentException(&quot;Invalid cron expression \&quot;&quot; + this.expression +
                    &quot;\&quot; led to runaway search for next trigger&quot;);
        }
        doNext(calendar, dot);
    }
}
</code></pre><p>findNext() 方法负责从 bitset 中找出下一个为 true 的值。  </p>
<p>OK，cronTrigger到这，来看另一个开箱即用的触发器。 </p>
<h3 id="PeriodicTrigger"><a href="#PeriodicTrigger" class="headerlink" title="PeriodicTrigger"></a>PeriodicTrigger</h3><p>顾名思义，周期性的触发器。周期性分为两种：fixedRate 和 fixedDelay。大家如果使用过线程池来实现简单定时任务，就应该不会陌生。前者是固定周期，而后者是相对上次执行完成的固定延迟。看下 nextExecutionTime 的实现就一目了然：</p>
<pre><code>public Date nextExecutionTime(TriggerContext triggerContext) {
        if (triggerContext.lastScheduledExecutionTime() == null) {
            return new Date(System.currentTimeMillis() + this.initialDelay);
        }
        else if (this.fixedRate) {
            return new Date(triggerContext.lastScheduledExecutionTime().getTime() + this.period);
        }
        return new Date(triggerContext.lastCompletionTime().getTime() + this.period);
    }
</code></pre><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>TaskScheduler 根据定时任务的不同配置定义了不同接口：</p>
<pre><code>public interface TaskScheduler {

     ScheduledFuture schedule(Runnable task, Trigger trigger);

       ScheduledFuture schedule(Runnable task, Date startTime);

     ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);

     ScheduledFuture scheduleAtFixedRate(Runnable task, long period);

        ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);

        ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);

}
</code></pre><p>有两个实现类，ThreadPoolTaskScheduler 和 ConcurrentTaskScheduler，大同小异，都使用了线程池。</p>
<h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><h3 id="Scheduled"><a href="#Scheduled" class="headerlink" title="Scheduled"></a>Scheduled</h3><p>很常用的一个注解，一般会指定一个 cron 表达式，当然，也可以通过指定 fixedDelay 或者 fixedRate 参数来实现任务的定时执行。如果不适用硬编码，还可以通过 fixedRateString 和 fixedDelayString 参数从配置文件读取间隔时间。<br>来看重点类 ScheduledAnnotationBeanPostProcessor ，它负责 对 Scheduled 注解的任务进行注册。</p>
<pre><code>private void processScheduled(Scheduled scheduled, Method method, Object bean) {
        try {
            Assert.isTrue(void.class.equals(method.getReturnType()),
                    &quot;Only void-returning methods may be annotated with @Scheduled&quot;);
            Assert.isTrue(method.getParameterTypes().length == 0,
                    &quot;Only no-arg methods may be annotated with @Scheduled&quot;);

        if (AopUtils.isJdkDynamicProxy(bean)) {
            try {
                // Found a @Scheduled method on the target class for this JDK proxy -&gt;
                // is it also present on the proxy itself?
                method = bean.getClass().getMethod(method.getName(), method.getParameterTypes());
            }
            catch (SecurityException ex) {
                ReflectionUtils.handleReflectionException(ex);
            }
            catch (NoSuchMethodException ex) {
                throw new IllegalStateException(String.format(
                        &quot;@Scheduled method &apos;%s&apos; found on bean target class &apos;%s&apos; but not &quot; +
                        &quot;found in any interface(s) for a dynamic proxy. Either pull the &quot; +
                        &quot;method up to a declared interface or switch to subclass (CGLIB) &quot; +
                        &quot;proxies by setting proxy-target-class/proxyTargetClass to &apos;true&apos;&quot;,
                        method.getName(), method.getDeclaringClass().getSimpleName()));
            }
        }
        else if (AopUtils.isCglibProxy(bean)) {
            // Common problem: private methods end up in the proxy instance, not getting delegated.
            if (Modifier.isPrivate(method.getModifiers())) {
                LogFactory.getLog(ScheduledAnnotationBeanPostProcessor.class).warn(String.format(
                        &quot;@Scheduled method &apos;%s&apos; found on CGLIB proxy for target class &apos;%s&apos; but cannot &quot; +
                        &quot;be delegated to target bean. Switch its visibility to package or protected.&quot;,
                        method.getName(), method.getDeclaringClass().getSimpleName()));
            }
        }

        Runnable runnable = new ScheduledMethodRunnable(bean, method);
        boolean processedSchedule = false;
        String errorMessage =
                &quot;Exactly one of the &apos;cron&apos;, &apos;fixedDelay(String)&apos;, or &apos;fixedRate(String)&apos; attributes is required&quot;;

        // Determine initial delay
        long initialDelay = scheduled.initialDelay();
        String initialDelayString = scheduled.initialDelayString();
        if (StringUtils.hasText(initialDelayString)) {
            Assert.isTrue(initialDelay &lt; 0, &quot;Specify &apos;initialDelay&apos; or &apos;initialDelayString&apos;, not both&quot;);
            if (this.embeddedValueResolver != null) {
                initialDelayString = this.embeddedValueResolver.resolveStringValue(initialDelayString);
            }
            try {
                initialDelay = Integer.parseInt(initialDelayString);
            }
            catch (NumberFormatException ex) {
                throw new IllegalArgumentException(
                        &quot;Invalid initialDelayString value \&quot;&quot; + initialDelayString + &quot;\&quot; - cannot parse into integer&quot;);
            }
        }

        // Check cron expression
        String cron = scheduled.cron();
        if (StringUtils.hasText(cron)) {
            Assert.isTrue(initialDelay == -1, &quot;&apos;initialDelay&apos; not supported for cron triggers&quot;);
            processedSchedule = true;
            if (this.embeddedValueResolver != null) {
                cron = this.embeddedValueResolver.resolveStringValue(cron);
            }
            this.registrar.addCronTask(new CronTask(runnable, cron));
        }
        // At this point we don&apos;t need to differentiate between initial delay set or not anymore
        if (initialDelay &lt; 0) {
            initialDelay = 0;
        }

        // Check fixed delay
        long fixedDelay = scheduled.fixedDelay();
        if (fixedDelay &gt;= 0) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            this.registrar.addFixedDelayTask(new IntervalTask(runnable, fixedDelay, initialDelay));
        }
        String fixedDelayString = scheduled.fixedDelayString();
        if (StringUtils.hasText(fixedDelayString)) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            if (this.embeddedValueResolver != null) {
                fixedDelayString = this.embeddedValueResolver.resolveStringValue(fixedDelayString);
            }
            try {
                fixedDelay = Integer.parseInt(fixedDelayString);
            }
            catch (NumberFormatException ex) {
                throw new IllegalArgumentException(
                        &quot;Invalid fixedDelayString value \&quot;&quot; + fixedDelayString + &quot;\&quot; - cannot parse into integer&quot;);
            }
            this.registrar.addFixedDelayTask(new IntervalTask(runnable, fixedDelay, initialDelay));
        }

        // Check fixed rate
        long fixedRate = scheduled.fixedRate();
        if (fixedRate &gt;= 0) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            this.registrar.addFixedRateTask(new IntervalTask(runnable, fixedRate, initialDelay));
        }
        String fixedRateString = scheduled.fixedRateString();
        if (StringUtils.hasText(fixedRateString)) {
            Assert.isTrue(!processedSchedule, errorMessage);
            processedSchedule = true;
            if (this.embeddedValueResolver != null) {
                fixedRateString = this.embeddedValueResolver.resolveStringValue(fixedRateString);
            }
            try {
                fixedRate = Integer.parseInt(fixedRateString);
            }
            catch (NumberFormatException ex) {
                throw new IllegalArgumentException(
                        &quot;Invalid fixedRateString value \&quot;&quot; + fixedRateString + &quot;\&quot; - cannot parse into integer&quot;);
            }
            this.registrar.addFixedRateTask(new IntervalTask(runnable, fixedRate, initialDelay));
        }

        // Check whether we had any attribute set
        Assert.isTrue(processedSchedule, errorMessage);
    }
    catch (IllegalArgumentException ex) {
        throw new IllegalStateException(
                &quot;Encountered invalid @Scheduled method &apos;&quot; + method.getName() + &quot;&apos;: &quot; + ex.getMessage());
    }
}
</code></pre><p>虽然代码这么长，但思路很简单，整理下：</p>
<ol>
<li>参数检验，被注解的方法必须是无参数且返回类型 void；</li>
<li>类的合法性检验，如果是基于 jdk 代理，则必须实现接口，如果是 cglib 代理，方法不能为 private；</li>
<li>检查 initialDelay 或 initialDelayString 参数，两个只能配置一个，如果配置的是 initialDelayString ，则赋值后将其转为 initialDelay；</li>
<li>检查 cron 表达式，cron 表达式和 initialDelay 不能同时配置。构造 CronTask 任务放入 cronTasks 中，值得一提的是，CronTask 给每一个任务添加了 CronTrigger 触发器 ；</li>
<li>检查 fixedDelay 参数，确保 cron，fixedDelay(String)，fixedRate(String) 只能配置一个。构造 IntervalTask 任务放入 fixedDelayTasks 中；</li>
<li>检查 fixedRate 参数，构造 IntervalTask 任务放入 fixedRateTasks 中；</li>
</ol>
<p>看完怎么将 Scheduled 注解的方法构造成任务后，我们继续看任务的执行是怎么实现的。<br>ScheduledTaskRegistrar 类继承了 InitializingBean ，类加载完后执行 scheduleTasks 方法。</p>
<pre><code>protected void scheduleTasks() {
    long now = System.currentTimeMillis();

    if (this.taskScheduler == null) {
        this.localExecutor = Executors.newSingleThreadScheduledExecutor();
        this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor);
    }
    if (this.triggerTasks != null) {
        for (TriggerTask task : this.triggerTasks) {
            this.scheduledFutures.add(this.taskScheduler.schedule(
                    task.getRunnable(), task.getTrigger()));
        }
    }
    if (this.cronTasks != null) {
        for (CronTask task : this.cronTasks) {
            this.scheduledFutures.add(this.taskScheduler.schedule(
                    task.getRunnable(), task.getTrigger()));
        }
    }
    if (this.fixedRateTasks != null) {
        for (IntervalTask task : this.fixedRateTasks) {
            if (task.getInitialDelay() &gt; 0) {
                Date startTime = new Date(now + task.getInitialDelay());
                this.scheduledFutures.add(this.taskScheduler.scheduleAtFixedRate(
                        task.getRunnable(), startTime, task.getInterval()));
            }
            else {
                this.scheduledFutures.add(this.taskScheduler.scheduleAtFixedRate(
                        task.getRunnable(), task.getInterval()));
            }
        }
    }
    if (this.fixedDelayTasks != null) {
        for (IntervalTask task : this.fixedDelayTasks) {
            if (task.getInitialDelay() &gt; 0) {
                Date startTime = new Date(now + task.getInitialDelay());
                this.scheduledFutures.add(this.taskScheduler.scheduleWithFixedDelay(
                        task.getRunnable(), startTime, task.getInterval()));
            }
            else {
                this.scheduledFutures.add(this.taskScheduler.scheduleWithFixedDelay(
                        task.getRunnable(), task.getInterval()));
            }
        }
    }
}
</code></pre><p>上面已经先了解了 TaskScheduler，这段代码做的事情就很明了了，首先初始化好 TaskScheduler，然后将所有不同队列中的任务放入其中，剩下的就交给线程池了。值得注意的是：spring 默认使用一个线程执行所有的定时任务。所以，通常需要配置下线程池的大小：</p>
<pre><code>&lt;task:scheduled-tasks scheduler=&quot;myScheduler&quot;&gt;
    &lt;task:scheduled ref=&quot;beanA&quot; method=&quot;methodA&quot; fixed-delay=&quot;5000&quot; initial-delay=&quot;1000&quot;/&gt;
    &lt;task:scheduled ref=&quot;beanB&quot; method=&quot;methodB&quot; fixed-rate=&quot;5000&quot;/&gt;
    &lt;task:scheduled ref=&quot;beanC&quot; method=&quot;methodC&quot; cron=&quot;*/5 * * * * MON-FRI&quot;/&gt;
&lt;/task:scheduled-tasks&gt;

&lt;task:scheduler id=&quot;myScheduler&quot; pool-size=&quot;10&quot;/&gt;
</code></pre><p>ok, schedule 模块的重点就先看到这里，虽然之前用过很多次，但看完源码之后，还是学到了很多配置的新方式。当然，看源码一方面是为了更好地使用  spring,另一方面更重要的是要从中学习其设计思想。fighting！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;schedule task 在工作场景中应该是需要频繁使用的。实现方式也很多，常见的当属 spring 自带的注解实现以及 quartz 框架。至于底层原理，使用线程池必不可少。今天就来揭开 spring 是如何对任务调度进行抽象。
    
    </summary>
    
      <category term="Spring源码" scheme="http://xuyajun.cn/categories/Spring%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>自省</title>
    <link href="http://xuyajun.cn/2017/03/26/%E8%87%AA%E7%9C%81/"/>
    <id>http://xuyajun.cn/2017/03/26/自省/</id>
    <published>2017-03-26T10:09:38.000Z</published>
    <updated>2017-03-26T10:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本是个阳光明媚的周末，或出去踏春，或隐于阳光一角看书，都能让我收获很久不从有的喜悦，毕竟，从小到大，爱好幻想的我一直认为阳光就是我的移动电源，有阳光，就会充满能量。但朋友圈和群消息等各个渠道都在义愤填膺讨论着一则新闻。是的，山东聊城“辱母杀人案”。<br><a id="more"></a><br>这不是我们第一次声讨社会，看过太多的警察不作为，太多的法官只会按照法律条文甚至偏袒恶势力执法。每次事件的曝光都能点满大众的怒气值，一顿口伐笔诛。然后，随着时间推移，每天上课的上课，上班的上班，在社会的重压下过着自己的生活。人呐，善忘！  </p>
<p>对这起案件，还需要表明自己的态度吗，引用人民日报的一段话：</p>
<blockquote>
<p>法律的社会功能是什么？可以说，法律不仅关乎规则，还关乎规则背后的价值诉求，关乎回应人心所向、塑造伦理人情。此案在半年过后掀起舆论波澜，正是因为其中蕴含着许多人的伦理诉求和情感诉求。</p>
</blockquote>
<p>相比案件本身，让我更加震动和悲哀的是网上评论中掺杂的极端”美分“言语，抛开一些门户网站故意带节奏不说，这些“美分”现实中确实不是少数。每每看着这些言论，我都一笑置之，我们的国家正在处于转型期，道德的沦落是无法逃避的痛苦过程。我相信，那些被冠以文明之名的国家在几十年前处于改革期，经济快速发展时，也是这样过来的。（讽刺的是，我并没有查阅任何资料来佐证自己的相信）  </p>
<p>但是，就算这个过程是通往文明社会的必经之路，那也是一条充满变数，凶多吉少的路啊。长期以来，似乎我天真的认为再过几十年，就能很自然的过渡到文明社会。这个文明难道不应该是我们努力实现的目标，而非我们只需等待即可享受的结果吗。难道不会存在再过几十年，社会道德彻底沦落，国家陷入动乱的可能吗？  </p>
<p>包括我在内的大多人都是普通人，我们不会变成好莱坞电影的超人，能力挽狂澜，以一己之力将良知播散到每个人的心中。甚至，我们能否做好自己都尚是未知数。想到这，宛如一束阳光进入了我的内心，唤醒了我。  </p>
<p>我只想做好自己，让自己过着有品质的生活的同时给社会带去一丝正能量。最近一直在看西方宗教，尝试去缕清犹太教，基督教和伊斯兰教之间千丝万缕的牵连。看完几本书后，领悟到西方文化和中华传统文化的不同，相比西方的宗教，我更喜欢传统文化的哲学。想到自己之前放弃深入学习自家传统文化而痴迷西方历史和文化，算是迷途知返吧。就在几十年前，我们的爷爷奶奶辈刚经历过战争苦难，被西方强行轰开大门，让国人散失了对五千年传统文化的信任。是时候恢复我们自己的文化自信了！</p>
<p>而对我而言，是时候回到继续学习心学的道路了。当初，在我处于困境时，是心学给了我信仰，让我完成了青年到成年的思想蜕化。工作后，过着温水煮蛙的日子，让自己逐渐散失了继续学习心学的热情。而社会的病态，习大大的以身作则，以及心学影响力的扩大，无不在提醒我，心学就是国人急需重拾的传统文化精华。  </p>
<p>“百无一用是书生”，学习传统文化的人只会“知乎者也”似乎已经成为社会的刻板印象。现代社会充斥着唯物主义，对传统文化和文人缺少了尊重。诚然，传统文化存在糟粕，而心学就是脱颖而出的哲学。心学强调个人的价值，做到“内圣外王”，而王阳明本人，在修心的基础上，建功立业，成为立德立言立功的圣人。  </p>
<p>找到自己的信仰不难，怎么去坚持学习才是考验。中途因为生活的舒适，自我的放任忘却本心也是学习心学的必经之路，毕竟，信仰对国人还算是个奢饰品。然而，这条路通向何方，需要自己去及时反省。  </p>
<p>目前心学在教科书上出现的次数并不多，大多是孔孟之道，颇有种”授人以鱼“的味道。小时候直接灌输尊老爱幼，孝顺父母等优秀传统没问题，但长大了有自主思维的时候，“授人以渔”才是正道。教育是最终的答案，希望下一代，下下一代除了会背三字经之外，还能领悟到：</p>
<blockquote>
<p>无善无恶心之体，有善有恶意之动，知善知恶是良知，为善去恶是格物。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本是个阳光明媚的周末，或出去踏春，或隐于阳光一角看书，都能让我收获很久不从有的喜悦，毕竟，从小到大，爱好幻想的我一直认为阳光就是我的移动电源，有阳光，就会充满能量。但朋友圈和群消息等各个渠道都在义愤填膺讨论着一则新闻。是的，山东聊城“辱母杀人案”。&lt;br&gt;
    
    </summary>
    
      <category term="哲学" scheme="http://xuyajun.cn/categories/%E5%93%B2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>《Netty权威指南》</title>
    <link href="http://xuyajun.cn/2017/03/11/%E3%80%8ANetty%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/"/>
    <id>http://xuyajun.cn/2017/03/11/《Netty权威指南》/</id>
    <published>2017-03-11T09:59:52.000Z</published>
    <updated>2017-03-11T10:08:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>Netty 已经是个非常成熟的通信框架，接触 Netty 也比较早，但只限于自己做个简单的 demo，然后把 reactor 模型挂在嘴边。直到最近几个月负责公司的云打印机业务，用 Netty 开发 tcp 服务器，才发现自己之前的云里雾里有点自欺欺人了。<a id="more"></a> 当然，这也是一种进步，对之前的很多知识都有了更深刻精准的理解。<br> Netty 是个优秀的框架毋庸置疑，但我并不打算细读其源码，java 的开源框架太多，框架的开发之道都大同小异，选其一二细阅便可，我们关注的应该是每个框架独特功能的设计艺术。<br> Netty 出现的背景不多介绍，这些个框架几乎都是开发者的银弹。自从有个 Netty，我相信几乎不会有公司会使用原生的 nio 来开发应用了。当然，我们可以思考，怎么样使用原生的 nio 去开发一个高可用，高扩展，高性能的通信应用。如果你有很清晰的思路，再来看看 Netty 或者 mina 这些，估计就有种惺惺相惜的感觉。<br>《Netty权威指南》这本书前半本都是讲 Netty 的实际应用开发，主要是服务器端和客户端的创建。后面半本着重进行了重要模块的源码分析。在这里我就略过应用开发，从源码分析角度总结下 Netty 的设计。（我们分析的是 Netty 4.0 版本。）<br>就像 nio 由 selector，channel，buffer 这三个核心 API 组成一样，Netty 也是由几个重要组件组成：</p>
<ul>
<li>ByteBuf</li>
<li>Channel</li>
<li>ChannelPipeLine</li>
<li>EventLoop</li>
</ul>
<p>一一来看。</p>
<h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><p>nio 是面向缓冲的，而原生的 ByteBuffer 太过于局限（比如长度固定）且易出错（比如 flip() 操作），因此，Netty 实现了自己的 ByteBuf。ByteBuf 使用了 readerIndex 和 writerIndex 两个游标使我们更方便的读写数据。来看下 ByteBuf 的类图：<br><img src="/images/ByteBuf.png" alt="alt text"><br>从内存分配的角度看，ByteBuf 分为两类： </p>
<ol>
<li>堆内存（HeapByteBuf）:内存分配和回收速度快，由 jvm 管理。但如果进行 I/O 读写，需要多一次的内存复制，将堆内存对应的缓冲区数据复制到内核中；</li>
<li>直接内存（DirectByteBuf）:这是 Netty 的高性能因素之一，可以使用系统的直接内存，少一次内存复制，读写更快。但相对应的，分配和回收速度会慢一些。</li>
</ol>
<p>从内存回收的角度看，ByteBuf 分为两类：</p>
<ol>
<li>基于对象池的 ByteBuf：可以重用 ByteBuf 对象，提高内存使用率，避免重复分配对象和频繁 GC；</li>
<li>普通 ByteBuf：每次都需要分配内存，使用完后等待回收。</li>
</ol>
<p>理解了这几类 ByteBuf 的存在，就不难理解为什么类图中有这些个子类了。<br>AbstractByteBuf 抽象类被称为是 ByteBuf 的 skeleton（骨骼），实现了大量读写方法。其中就包括 ByteBuf 的动态扩展特性。我们从源码来看下 ByteBuf 的扩容策略。</p>
<pre><code>private int calculateNewCapacity(int minNewCapacity) {
    final int maxCapacity = this.maxCapacity;
    final int threshold = 1048576 * 4; // 4 MiB page

    if (minNewCapacity == threshold) {
        return threshold;
    }

    // If over threshold, do not double but just increase by threshold.
    if (minNewCapacity &gt; threshold) {
        int newCapacity = minNewCapacity / threshold * threshold;
        if (newCapacity &gt; maxCapacity - threshold) {
            newCapacity = maxCapacity;
        } else {
            newCapacity += threshold;
        }
        return newCapacity;
    }

    // Not over threshold. Double up to 4 MiB, starting from 64.
    int newCapacity = 64;
    while (newCapacity &lt; minNewCapacity) {
        newCapacity &lt;&lt;= 1;
    }

    return Math.min(newCapacity, maxCapacity);
}
</code></pre><p>可以看到 Netty 使用了大多数系统都会采用的先倍增后步进的策略，并将阀值设置为 4MB。当新容量小于阀值时，从 64 开始倍增，直到倍增后的结果大于容量值；当容量大于阀值时，采用以阀值步进的方式。通过这种策略，很好的实现了性能和功能的最优化。<br>再来看看另一个抽象类 AbstractReferenceCountedByteBuf 。该类主要是对引用进行计数，类似 JVM 内存回收的对象引用计数器，做自动内存回收。该类比较简单，主要有 retain0() 和 release0() 方法，分别对计数器进行增加和减少操作。看下 release0():</p>
<pre><code>private boolean release0(int decrement) {
    for (;;) {
        int refCnt = this.refCnt;
        if (refCnt &lt; decrement) {
            throw new IllegalReferenceCountException(refCnt, -decrement);
        }

        if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) {
            if (refCnt == decrement) {
                deallocate();
                return true;
            }
            return false;
        }
    }
}
</code></pre><p>当 refCnt 为 1 时，就释放内存，deallocate() 由各个子类实现。而这种使用原子类的 CAS 来进行加减已经成为标准，不做详述。<br>Buffer 模块的源码难点在于 PooledByteBuf 内存池的设计，这里不做源码分析，简单描述下算法：Netty 的 内存池管理类是 PoolArena 。 而 PoolArena 是由多个 PoolChunk 组成的大块内存区域，PoolChunk 又由多个 PoolSubpage 组成。Chunk 中的 Page 被构建成一颗二叉树，假如 Chunk 由 16 个 Page 组成，则将会以下图的结构组织起来。<br><img src="/images/Chunk.png" alt="alt text">     </p>
<p>当需要分配内存，就会从这棵树上进行分配，并将标记节点的分配状态。<br>对于小于一个 Page 的内存分配，则在 Page 中完成，但每个 Page 会被切成大小相同的多个存储块，存储块的大小由第一次申请的内存块决定。<br>至于回收，通过状态位来标记内存是否可用，还记得上面提到的引用计数器吗，这时候就发挥作用了～ </p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Channel 是 Netty 网络操作接口，包含但不限于网路的读写，客户端发起连接，主动关闭连接，获取双方的网络地址，同时也包含了 Netty 框架相关的功能，比如获取该 Channel 的 EventLoop，获取缓冲分配器 ByteBufAllocator 和处理链 ChannelPineline。<br>Channel 的实现类实在太多，我们最熟悉的应该是 NioServerSocketChannel 和 NioSocketChannel 了。<br>要想了解 它们俩，还得先看下 channel 的骨骼类 AbstractChannel。AbstractChannel 看起来倒也不累，反倒觉得很简单，所有的网络事件都直接交给我们另一个组件 ChannelPineline 做了。自己实现了一些公共的 API，比如 localAddress()，功能只要与子类强相关，就将方法定义为抽象，交给子类实现。<br>继续看 AbstractNioChannel，到了这里，我们就有些熟悉感了，看到了点核心代码。</p>
<pre><code>protected void doRegister() throws Exception {
    boolean selected = false;
    for (;;) {
        try {
            selectionKey = javaChannel().register(eventLoop().selector, 0, this);
            return;
        } catch (CancelledKeyException e) {
            if (!selected) {
                // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be
                // cached and not removed because no Select.select(..) operation was called yet.
                eventLoop().selectNow();
                selected = true;
            } else {
                // We forced a select operation on the selector before but the SelectionKey is still cached
                // for whatever reason. JDK bug ?
                throw e;
            }
        }
    }
}
</code></pre><p>该方法实现了 Channel 的注册，继续进入 register() 方法会看到原生的 nio API。<br>来到最接近 NioSocketChannel 的类 AbstractNioByteChannel。里面只有一个成员变量：<br><code>private Runnable flushTask;</code><br>看下核心方法 doWrite()：</p>
<pre><code>protected void doWrite(ChannelOutboundBuffer in) throws Exception {
    int writeSpinCount = -1;

    boolean setOpWrite = false;
    for (;;) {
        Object msg = in.current();
        if (msg == null) {
            // Wrote all messages.
            clearOpWrite();
            // Directly return here so incompleteWrite(...) is not called.
            return;
        }

        if (msg instanceof ByteBuf) {
            ByteBuf buf = (ByteBuf) msg;
            int readableBytes = buf.readableBytes();
            if (readableBytes == 0) {
                in.remove();
                continue;
            }

            boolean done = false;
            long flushedAmount = 0;
            if (writeSpinCount == -1) {
                writeSpinCount = config().getWriteSpinCount();
            }
            for (int i = writeSpinCount - 1; i &gt;= 0; i --) {
                int localFlushedAmount = doWriteBytes(buf);
                if (localFlushedAmount == 0) {
                    setOpWrite = true;
                    break;
                }

                flushedAmount += localFlushedAmount;
                if (!buf.isReadable()) {
                    done = true;
                    break;
                }
            }

            in.progress(flushedAmount);

            if (done) {
                in.remove();
            } else {
                // Break the loop and so incompleteWrite(...) is called.
                break;
            }
        } else if (msg instanceof FileRegion) {
            FileRegion region = (FileRegion) msg;
            boolean done = region.transfered() &gt;= region.count();

            if (!done) {
                long flushedAmount = 0;
                if (writeSpinCount == -1) {
                    writeSpinCount = config().getWriteSpinCount();
                }

                for (int i = writeSpinCount - 1; i &gt;= 0; i--) {
                    long localFlushedAmount = doWriteFileRegion(region);
                    if (localFlushedAmount == 0) {
                        setOpWrite = true;
                        break;
                    }

                    flushedAmount += localFlushedAmount;
                    if (region.transfered() &gt;= region.count()) {
                        done = true;
                        break;
                    }
                }

                in.progress(flushedAmount);
            }

            if (done) {
                in.remove();
            } else {
                // Break the loop and so incompleteWrite(...) is called.
                break;
            }
        } else {
            // Should not reach here.
            throw new Error();
        }
    }
    incompleteWrite(setOpWrite);
}
</code></pre><p>有点长，来整理下逻辑： </p>
<ol>
<li>从消息环形数组 ChannelOutboundBuffer 中取出一条消息，如果空，则说明消息都发送完毕，清除半包标识，return；</li>
<li>如果消息是 ByteBuf 类型，判断可读字节数，如果为 0，删除消息，continue；如果消息可发送，从配置对象中获取循环发送次数 writeSpinCount。设置写半包循环最大次数是为了防止 I/O 线程一直尝试写操作，这样造成其它 I/O 操作无法进行。经历 for循环后，如果发送成功，则将已发送的数据从 ChannelOutboundBuffer 中删除，否则 break，进入 incompleteWrite() 方法；</li>
<li>如果消息是 FileRegion 类型（用于文件传输），处理逻辑和 ByteBuf 类型一样。</li>
</ol>
<p>至于 incompleteWrite() 方法，也来看下吧：</p>
<pre><code>protected final void incompleteWrite(boolean setOpWrite) {
        // Did not write completely.
        if (setOpWrite) {
            setOpWrite();
        } else {
            // Schedule flush again later so other tasks can be picked up in the meantime
            Runnable flushTask = this.flushTask;
            if (flushTask == null) {
                flushTask = this.flushTask = new Runnable() {
                    @Override
                    public void run() {
                        flush();
                    }
                };
            }
            eventLoop().execute(flushTask);
        }
    }
</code></pre><p>总算看到唯一的成员变量 flushTask 派上用场了。首先判断是否需要设置写半包标识，也就是将 SelectionKey 设置成可写的。只要设置成可写，多路复用器会不停轮询对应的 channel，因此不需要再启动独立的线程。如果没有设置写操作位，则将 flushTask 加入到 EventLoop 中。<br>Channel 要想一整套看下来还是很耗精力的，由于设计方法的高超，到了 NioServerSocketChannel 这儿，其实已经不需要做什么事了。</p>
<h2 id="ChannelPipeLine"><a href="#ChannelPipeLine" class="headerlink" title="ChannelPipeLine"></a>ChannelPipeLine</h2><p>真正处理业务逻辑的当属 ChannelPipeline 和 ChannelHandler 了。该模块理解起来很简单，类似于 web 中的过滤器，也就是使用责任链模式设计而成。这里就只提下自己遇到的坑：</p>
<ol>
<li>ChannelPipeline 线程安全，但 ChannelHandler 并非线程安全。鉴于我们自定义 handler 时都是采用注解 @Sharable ，也就是链路共用一个 handler，而非每条链路都创建一个私有 handler，所有我们要保证 handler 的线程安全；</li>
<li>继承 ByteToMessageDecoder 自定义解码器时，要注意读半包问题。</li>
</ol>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>Netty 中的 NioEventLoop 对 nio 中的多路复用器 Selector 进行了装饰。之前自己写过的 nio 代码在该类都能找到点影子，来看段长代码 run() 方法：</p>
<pre><code>protected void run() {
    for (; ; ) {
        try {
            switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {
                case SelectStrategy.CONTINUE:
                    continue;
                case SelectStrategy.SELECT:
                    select(wakenUp.getAndSet(false));
                    if (wakenUp.get()) {
                        selector.wakeup();
                    }
                default:
                    // fallthrough
            }

            cancelledKeys = 0;
            needsToSelectAgain = false;
            final int ioRatio = this.ioRatio;
            if (ioRatio == 100) {
                try {
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    runAllTasks();
                }
            } else {
                final long ioStartTime = System.nanoTime();
                try {
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    final long ioTime = System.nanoTime() - ioStartTime;
                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
        // Always handle shutdown even if the loop processing threw an exception.
        try {
            if (isShuttingDown()) {
                closeAll();
                if (confirmShutdown()) {
                    return;
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
    }
}
</code></pre><p>老规矩，整理下逻辑：</p>
<ol>
<li>通过 hasTasks() 判断消息队列中是否有任务，如果没有，则调用 selector() 方法处理 I/O 事件；</li>
<li>由于 NioEventLoop 需要同时处理 I/O 事件和非 I/O 任务，为了保证两者都能够被执行，Netty 提供了参数 ioRatio 来定义 I/O 事件处理时间比例，默认 50%。runAllTasks() 方法用来处理队列中的非 I/O 任务，并且分配的时间到了给定的时间就退出，等待下次处理；</li>
<li>处理完所有事件后，判断系统是否进入优雅停机状态，如果关闭，则调用 closeAll()，释放资源，并让 NioEventLoop 线程退出循环。</li>
</ol>
<p>囫囵吞枣般的跟书浏览了下源码，虽然没有一步消化到位，不过对于理解 Netty 的设计思想和模块分工，还是很有作用，也解决了不少项目中遇到的问题。后期如果需要对 Netty 项目进行优化，再来进行进一步强化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Netty 已经是个非常成熟的通信框架，接触 Netty 也比较早，但只限于自己做个简单的 demo，然后把 reactor 模型挂在嘴边。直到最近几个月负责公司的云打印机业务，用 Netty 开发 tcp 服务器，才发现自己之前的云里雾里有点自欺欺人了。
    
    </summary>
    
      <category term="读书笔记" scheme="http://xuyajun.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>温故知新</title>
    <link href="http://xuyajun.cn/2017/02/19/%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/"/>
    <id>http://xuyajun.cn/2017/02/19/温故知新/</id>
    <published>2017-02-19T12:34:33.000Z</published>
    <updated>2017-02-19T12:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>17 年的第一篇文字，来的有点迟。最近身边充斥着各种跳槽信息，毕竟年初。<a id="more"></a>工作了半年多，我也深知自己的处境，毕业没有选择去大公司，让自己处在一个比较安逸，可能已经逐渐失去竞争力而浑然不知的环境。居安思危，我回忆了下校招面试题，结合网上各种社招经验好文，尝试去回答。结果是有点被打击的，很多基础知识都已经记不太清。当然，如果真的准备跳槽，这些都是可以临时抱佛脚。为了方便自己能够随时迅速重拾这些基础知识，我打算在今年增开一个博文栏目，将这些面试必需的基础知识系统整理，就叫“温故知新”吧。而本文就是该栏目第一篇，分门别类的列出所需掌握的主知识点。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><a href="">集合类源码剖析</a><br>JUC 类源码剖析<br>NIO 模型<br>多线程<br>虚拟机内幕<br>Web 框架<br>设计模式</p>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="计算机系统原理"><a href="#计算机系统原理" class="headerlink" title="计算机系统原理"></a>计算机系统原理</h2><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;17 年的第一篇文字，来的有点迟。最近身边充斥着各种跳槽信息，毕竟年初。
    
    </summary>
    
      <category term="温故知新" scheme="http://xuyajun.cn/categories/%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-context（cache）</title>
    <link href="http://xuyajun.cn/2016/12/25/Spring-context%EF%BC%88cache%EF%BC%89/"/>
    <id>http://xuyajun.cn/2016/12/25/Spring-context（cache）/</id>
    <published>2016-12-25T14:19:52.000Z</published>
    <updated>2016-12-25T14:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>context 主要提供了 cache，jndi，schedule，script 等功能的抽象。选取 cache 和 schedule 两个有代表性的来阅读吧，其他模块暂时不细读。<a id="more"></a>package 如下：<br><img src="/images/spring-context.png" alt="alt text">  </p>
<h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>平时应用中配置的基本都是 encache 缓存，现在细想一下，spring 既然支持集成三方缓存，就必然在底层封装了一层抽象，这样就既可以使用内部实现又能够支持三方的东西。想到这，context 工程下这么多抽象也就能够理解了。<br>既然是对 cache 提供抽象，按照经验，也多多少少能猜到点套路，主要围绕提供缓存注解及注解处理器，缓存管理器。以老司机的心态来让我们一步步剥开～</p>
<h3 id="缓存相关的注解"><a href="#缓存相关的注解" class="headerlink" title="缓存相关的注解"></a>缓存相关的注解</h3><ol>
<li>@Cacheable<br> 用来表示该方法是可缓存的，当有相同 key 的请求来时，函数不必重复执行，直接从缓存中获取。至于这个 key，依赖于函数的所有参数或部分有区分度的参数。为了实现自定义部分参数生成 key，就必须提一下 SpEL（spring 表达式语言），它还可以帮助你实现条件缓存。（😂真的只是提一下，不了解的请自行看官方文档）</li>
<li>@CacheEvict<br> 和 Cacheable 相反，该注解用于删除缓存。用户可以选择执行一个方法后，在缓存中删除该 key 的 entry 或者直接删除全部 entry。</li>
<li>@CachePut<br> 对方法使用该注解，将会每次都执行方法，并将结果更新到缓存中</li>
<li>@Caching<br> 当需要对一个方法进行多个相同类型的注解时，可以使用该注解，允许你指定多个 Cacheable／CachePut／CacheEvict。  </li>
</ol>
<p>在你对自己感兴趣的方法或类上进行了缓存注解后，并不能生效，需要你在 xml 中使用<code>&lt;cache:annotation-driven/&gt;</code>或者在 java 代码中使用 @EnableCaching 注解来开启缓存管理功能。    </p>
<h3 id="扫描缓存注解"><a href="#扫描缓存注解" class="headerlink" title="扫描缓存注解"></a>扫描缓存注解</h3><p>AnnotationCacheOperationSource 类用来查找类或方法中与 cache 相关的一种或多种注解，如果构造器不传入 CacheAnnotationParser ，则默认使用 SpringCacheAnnotationParser 来扫描这个类或方法。而 SpringCacheAnnotationParser 继承了 CacheAnnotationParser 接口，实现了对 cache 相关的所有注解的扫描并封装成 Collection<cacheoperation> 返回。  </cacheoperation></p>
<pre><code>@Override
    public Collection&lt;CacheOperation&gt; parseCacheAnnotations(AnnotatedElement ae) {
        Collection&lt;CacheOperation&gt; ops = null;

        Collection&lt;Cacheable&gt; cacheables = getAnnotations(ae, Cacheable.class);
        if (cacheables != null) {
            ops = lazyInit(ops);
            for (Cacheable cacheable : cacheables) {
                ops.add(parseCacheableAnnotation(ae, cacheable));
            }
        }
        Collection&lt;CacheEvict&gt; evicts = getAnnotations(ae, CacheEvict.class);
        if (evicts != null) {
            ops = lazyInit(ops);
            for (CacheEvict evict : evicts) {
                ops.add(parseEvictAnnotation(ae, evict));
            }
        }
        Collection&lt;CachePut&gt; puts = getAnnotations(ae, CachePut.class);
        if (puts != null) {
            ops = lazyInit(ops);
            for (CachePut put : puts) {
                ops.add(parsePutAnnotation(ae, put));
            }
        }
        Collection&lt;Caching&gt; cachings = getAnnotations(ae, Caching.class);
        if (cachings != null) {
            ops = lazyInit(ops);
            for (Caching caching : cachings) {
                ops.addAll(parseCachingAnnotation(ae, caching));
            }
        }

        return ops;
    } 
</code></pre><h3 id="缓存管理器"><a href="#缓存管理器" class="headerlink" title="缓存管理器"></a>缓存管理器</h3><p>CacheManager 接口有多种实现，SimpleCacheManager 是针对应用只有一个 CacheManager，CompositeCacheManager 是针对多个 CacheManager，而 NoOpCacheManager 则是特殊的管理器，当你使用 CompositeCacheManager 配置了好几个缓存管理器时，可能会需要这种管理器来返回一个 Cache 的子类 NoOpCache。除了这三种，EhCacheCacheManager 和 JCacheCacheManager 也支持了 encache 和 java 的缓存（这就是抽象的目的）。 </p>
<h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><p>spring 可以让你通过 @EnableCaching 的 mode 值来选择是使用 基于 java 的代理（<em>AdviceMode.PROXY</em>）或者通过基于编织的 AspectJ（<em>AdviceMode.ASPECTJ</em>）来实现缓存的 aop。 </p>
<p>来看下为了缓存内部实现的切面 CacheAspectSupport ，核心方法 execute 实现了对方法缓存注解的扫描并进行相应操作，代码如下：</p>
<pre><code>protected Object execute(Invoker invoker, Object target, Method method, Object[] args) {
        // check whether aspect is enabled
        // to cope with cases where the AJ is pulled in automatically
        if (!this.initialized) {
            return invoker.invoke();
        }

        // get backing class
        Class&lt;?&gt; targetClass = AopProxyUtils.ultimateTargetClass(target);
        if (targetClass == null &amp;&amp; target != null) {
            targetClass = target.getClass();
        }
        Collection&lt;CacheOperation&gt; cacheOp = getCacheOperationSource().getCacheOperations(method, targetClass);

        // analyze caching information
        if (!CollectionUtils.isEmpty(cacheOp)) {
            Map&lt;String, Collection&lt;CacheOperationContext&gt;&gt; ops = createOperationContext(cacheOp, method, args, target, targetClass);
            // start with evictions
            inspectBeforeCacheEvicts(ops.get(EVICT));
            // follow up with cacheable
            CacheStatus status = inspectCacheables(ops.get(CACHEABLE));
            Object retVal;
            Map&lt;CacheOperationContext, Object&gt; updates = inspectCacheUpdates(ops.get(UPDATE));
            if (status != null) {
                if (status.updateRequired) {
                    updates.putAll(status.cacheUpdates);
                }
                // return cached object
                else {
                    return status.retVal;
                }
            }
            retVal = invoker.invoke();
            inspectAfterCacheEvicts(ops.get(EVICT), retVal);
            if (!updates.isEmpty()) {
                update(updates, retVal);
            }
            return retVal;
        }

        return invoker.invoke();
    }
</code></pre><p>该抽象类子类 CacheInterceptor 实现了 MethodInterceptor 的 invoke 方法：</p>
<pre><code>public Object invoke(final MethodInvocation invocation) throws Throwable {
        Method method = invocation.getMethod();

        Invoker aopAllianceInvoker = new Invoker() {
            public Object invoke() {
                try {
                    return invocation.proceed();
                } catch (Throwable ex) {
                    throw new ThrowableWrapper(ex);
                }
            }
        };

        try {
            return execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments());
        } catch (ThrowableWrapper th) {
            throw th.original;
        }
    }
</code></pre><p>cache 抽象的重点就是这些了，主要借助于 aop 。可以预测，spring 中的其他大部分功能比如事务都是得益于 aop。本文没有对 aop 进行过多讲解，但其实 aop 才是真正值得深挖的点。很期待去挑战！</p>
<hr>
<p>为了更好的理解源码，最理想的是要对自己阅读部分的功能做个了解，这也是为什么建议大家在 spring 灵活运用的基础上再挑战源码。但平时使用的 spring 应用可能并无法覆盖所有功能，所以再阅读到没使用过的功能时，可以建助 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#cache-annotations-cacheable" target="_blank" rel="external">spring 官方文档</a>来先了解这个功能，比如本文中的 cache 注解支持对笔者来说未在实际中应用过，通过先从文档了解这个功能，使用步骤后再阅读源码，就不那么云里雾里，反而还觉得顺理成章，就是应该这样实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;context 主要提供了 cache，jndi，schedule，script 等功能的抽象。选取 cache 和 schedule 两个有代表性的来阅读吧，其他模块暂时不细读。
    
    </summary>
    
      <category term="Spring源码" scheme="http://xuyajun.cn/categories/Spring%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>《redis 的设计与实现》</title>
    <link href="http://xuyajun.cn/2016/11/27/%E3%80%8Aredis%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"/>
    <id>http://xuyajun.cn/2016/11/27/《redis 的设计与实现》/</id>
    <published>2016-11-27T10:50:28.000Z</published>
    <updated>2016-11-27T11:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到有人这样形容 redis,像一把瑞士军刀，小巧，锋利，实用。在之前对 redis 虽有了解，却无法体会到这种感觉。看完这本同样精美的书，难抑赞赏之情。redis 在很多场景确实是很好的方案，不仅可以当数据库用，还可以拿来当消息队列，缓存来使。更重要的是，看完它的设计与实现，更能够意识到：任何精美的技术产品都不是飘在云端，可望不可即，深挖底层，就能掌握一切窍门。（这也是笔者一直坚持在做的事💪🏼）<a id="more"></a></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>让我们从一张图开始学习 redis 为了支持多种数据类型实现了哪些高效率的数据结构。<br><img src="/images/redisobject.png" alt="alt text">     </p>
<p>正如图中看到的，redis 不像 memcached 只支持了字符串类型，需求量大的列表，集合，有序集合，哈希表都能支持。而支撑这些类型的是底层多种数据结构，每种类型可以由不同的数据结构实现，书中称之为编码方式。redis 将数据类型，编码方式，指针等信息封装成 redisObject，可以理解为 redis 是 &lt; sds,redisObject &gt;键值对数据库。redisObject 结构体如下：</p>
<pre><code>typedef struct redisObject{
    //类型
    unsigned type:4;
    //对齐位
    unsigned notused:2;
    //编码方式
    unsigned encoding:4;
    //LRU时间
    unsigned lru:22;
    //引用计数
    int refcount;
    //指向对象的值
    void *ptr;
}robj;
</code></pre><p>接下来让我们挨个看下这些数据结构怎么被封装的。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code>struct sdshdr{
    //buf已占用长度
    int len;
    //buf剩余可用长度
    int free;
    //实际保存字符串数据的地方
    char buf[];
}
</code></pre><p>相比 C 语言中的 char* ，redis 封装 sds 用来表示字符串主要有下面三个好处：</p>
<ul>
<li>高效执行长度计算，O(1) 复杂度</li>
<li>高效执行追加操作（预分配内存，减少内存分配次数，用空间换时间）</li>
<li>二进制安全（程序不应对字符串保存的数据做任何假设，数据可以是以 “\0” 结尾，也可以是单纯的字节数组或其他格式数据。而 C 中的char * 以 “\0” 结束）</li>
</ul>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><pre><code>typedef struct intset{
    //保存元素所使用的类型的长度
    uint32_t encoding;
    //元素个数
    uint32_t length;
    //保存元素的数组
    int8_t contents[];
}intset;
</code></pre><p>整数集合用于有序，无重复的保存多个整数，并会根据元素的值，自动选择使用什么长度的整数类型来保存，但只支持升级，不支持降级。</p>
<h3 id="双端链表"><a href="#双端链表" class="headerlink" title="双端链表"></a>双端链表</h3><pre><code>typedef struct listNode{
        //前驱节点
        struct listNode* prev;
        //后驱节点
        struct listNode* next;
        //值
        void *value;
    }listNode;

typedef struct list{
    //表头指针
    listNode *head;
    //表尾指针
    listNode *tail;
    //节点数量
    unsigned long len;
    //复制函数
    void *(*dup)(void *ptr);
    //释放函数
    void *(*free)(void *ptr);
    //对比函数
    int (*match)(void *ptr,void *key);
}list;

typedef struct listIter{
    //下一节点
    listNode *next;
    //迭代方向
    int direction;
}listIter;        
</code></pre><p>由于 C 本身不支持链表，所以 redis 像其他 C 程序一样，对链表进行了自己的实现。至于双端链表的特点，就不在此细说。</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code>typedef struct dict{
        //特定于类型的处理函数
        dictType *type;
        //类型处理函数的私有数据
        void *privdata;
        //哈希表（2个，用来实现渐进式 rehash）
        dictht ht[2];
        //记录 rehash 进度的标志，－1表示 rehash 未进行
        int rehashidx;
        //当前正在运作的安全迭代器数量
        int iterators;
    }dict;

typedef struct dictht{
    //哈希表节点指针数组（俗称桶，bucket）
    dictEntry **table;
    //指针数组的大小
    unsigned long size;
    //指针数组的长度掩码，用于计算索引值
    unsigned long sizemask;
    //哈希表现有的节点数量
    unsigned long used;
}dictht;

typedef struct dictEntry{
    //键
    void *key;
    //值
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
    }v;
    //链后继节点
    struct dictEntry *next;
}dictEntry;

typedef struct dictIterator{
    //正在迭代的字典
    dict *d;
    //正在迭代的哈希表号码（0/1）
    int table;
    //正在迭代的哈希表数组的索引
    int index;
    //是否安全
    int safe;
    //当前哈希节点
    dictEntry *entry;
    //当前哈希节点的后继节点
    dictEntry *nextEntry;
}dictIterator; 
</code></pre><p>   看书看到这里的时候有点懵逼，被书中的哈希键，哈希表，字典一下子整乱了。这里需要梳理下：<br>   redis 使用了高效且实现简单的哈希表来作为字典的底层实现。而上图 redisobjcet 中的数据类型中也有个哈希表，这个代表上层的数据类型，也被叫做散列。实际上，redis 中的散列类型使用字典和压缩链表两种作为底层实现，因为压缩链表比较节省内存，所以在新建 Hash 键时，默认使用压缩链表，当满足某些条件时，底层才转化为字典。</p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p><img src="/images/ziplist.png" alt="alt text"><br>ziplist是由一系列特殊编码的内存块构成的列表(所以不像其他数据结构用结构体表示)，可以保存字符数组或整数值，用来作为散列，列表和有序集合的底层实现之一。</p>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><pre><code>typedef struct zskiplist{
    //头节点，尾节点
    struct zskiplistNode *header,*tail;
    //节点数量
    unsigned long len;
    //目前表内节点的最大层数
    int level;
}zskiplist;

typedef struct zskiplistNode{
    //member对象
    robj *obj;
    //分值
    double score;
    //后退指针
    struct zskiplistNode *backward;
    //层
    struct zskiplistLevel{
        //前进指针
        struct zskiplistNode *forward;
        //这个层跨越的节点数量
        unsigned int span;
    }level[];
}zskiplistNode;
</code></pre><p>跳跃表的效率可以和平衡树媲美－查找，删除，添加的时间复杂度都可以达到 O(logN)，并且，跳跃表的实现要简单的多。<br>跳越表在 redis 中主要用来实现有序集合。</p>
<h2 id="功能一览"><a href="#功能一览" class="headerlink" title="功能一览"></a>功能一览</h2><p>看完了这些底层，也就不难理解 redis 是如何实现那些数据库必备的功能了。无非是在底层数据结构基础之上加上一些逻辑。我们来简单过下书中提到的功能，更全功能请看<a href="http://www.redis.cn/documentation.html" target="_blank" rel="external">官方文档</a>：</p>
<h3 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h3><ul>
<li>当客户端使用 MULTI 开始事务时，会用事务队列保存客户端的命令</li>
<li>使用 WATCH 命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 选项打开，这样客户端执行事务时，直接返回失败</li>
<li>redis 事务只保证一致性和隔离性，不保证原子性和持久性</li>
</ul>
<h3 id="订阅与发布："><a href="#订阅与发布：" class="headerlink" title="订阅与发布："></a>订阅与发布：</h3><ul>
<li>订阅信息由服务器进程维护的 redisServer.pubsub_channels 字典保存，字典的键为被订阅的频道，字典的值为订阅频道的所有客户端</li>
<li>当有新消息发送到频道上，程序遍历频道所对应的所有客户端，然后发送消息</li>
<li>订阅模式的信息由 redisServer.pubsub_patterns 链表保存，链表的每个节点都保存着一个 pubsubPattern 结构，结构中保存着被订阅的模式，以及订阅该模式的客户端。</li>
</ul>
<h3 id="lua脚本："><a href="#lua脚本：" class="headerlink" title="lua脚本："></a>lua脚本：</h3><ul>
<li>EVAL 命令为输入脚本定义一个 Lua 函数，然后通过执行这个函数来执行脚本</li>
<li>EVALSHA 通过构建函数名，直接调用 Lua 中已定义的函数，从而执行相应的脚本</li>
</ul>
<h3 id="满查询日志："><a href="#满查询日志：" class="headerlink" title="满查询日志："></a>满查询日志：</h3><ul>
<li>redis 用一个链表以 FIFO 的顺序保存着所有慢查询日志</li>
<li>每条慢查询日志以一个慢查询节点表示，节点中记录着执行超时的命令，命令的参数，命令执行的时间以及执行命令所消耗的时间等信息</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB:"></a>RDB:</h3><ul>
<li>rdbSave 会将数据库数据保存到 RDB 文件，并在保存之前阻塞调用者</li>
<li>SAVE 命令直接调用 rdbSave ，阻塞主进程，BGSAVE 用子进程调用，主进程可以继续处理请求</li>
<li>SAVE 执行期间，AOF 写入可以在后台线程进行，BGREWRITEAOF 可以在子进程进行，所以这三种操作可以同时进行</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF:"></a>AOF:</h3><ul>
<li>AOF 文件通过保存所有修改数据库的命令来记录数据库的状态</li>
<li>AOF 文件中的所有命令都以 Redis 通讯协议的格式保存</li>
<li>不同的 AOF 保存模式（ AOF_FSYNC_NO ／ AOF_FSYNC_EVERYSEC / AOF_FSYNC_ALWAYS）对数据的安全性，以及 redis 的性能有很大的影响</li>
<li>AOF 重写是为了用更小的体积来保存数据库状态</li>
</ul>
<h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a>事件：</h3><ul>
<li>redis 的事件分为时间事件和文件事件</li>
<li>文件事件分为读事件和写事件：读事件实现了命令请求的接受，写事件实现了命令结果的返回</li>
<li>时间事件分为单次执行事件和循环执行事件，服务器 serverCron 就是循环事件</li>
<li>文件事件和时间事件是合作关系：一种事件会等待另一种事件完成之后再执行，不会出现抢占情况</li>
</ul>
<p>redis 虽然可以落地，但毕竟是基于内存的，所以适用场景还主要集中于小而热的数据。我想，这也是为什么被形容为瑞士军刀的原因，不能指望它去支撑过大的数据量，那是 mongodb,hbase 份内的事。可惜的是，笔者还没有实战过大数据量情况下使用 redis 性能会如何，已经迫不及待啦！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到有人这样形容 redis,像一把瑞士军刀，小巧，锋利，实用。在之前对 redis 虽有了解，却无法体会到这种感觉。看完这本同样精美的书，难抑赞赏之情。redis 在很多场景确实是很好的方案，不仅可以当数据库用，还可以拿来当消息队列，缓存来使。更重要的是，看完它的设计与实现，更能够意识到：任何精美的技术产品都不是飘在云端，可望不可即，深挖底层，就能掌握一切窍门。（这也是笔者一直坚持在做的事💪🏼）
    
    </summary>
    
      <category term="读书笔记" scheme="http://xuyajun.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>除了拥抱，别的都不想要</title>
    <link href="http://xuyajun.cn/2016/11/16/%E9%99%A4%E4%BA%86%E6%8B%A5%E6%8A%B1%EF%BC%8C%E5%88%AB%E7%9A%84%E9%83%BD%E4%B8%8D%E6%83%B3%E8%A6%81/"/>
    <id>http://xuyajun.cn/2016/11/16/除了拥抱，别的都不想要/</id>
    <published>2016-11-16T14:42:18.000Z</published>
    <updated>2016-11-27T10:54:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="除了拥抱，别的都不想要"><a href="#除了拥抱，别的都不想要" class="headerlink" title="除了拥抱，别的都不想要"></a>除了拥抱，别的都不想要</h2><h6 id="谢谢你，仿佛迷雾星辰，深海灯塔，温暖我整个漫长冬夜。"><a href="#谢谢你，仿佛迷雾星辰，深海灯塔，温暖我整个漫长冬夜。" class="headerlink" title="谢谢你，仿佛迷雾星辰，深海灯塔，温暖我整个漫长冬夜。"></a>谢谢你，仿佛迷雾星辰，深海灯塔，温暖我整个漫长冬夜。</h6><p>从某种意义上来说，这是一份内心独白。<a id="more"></a>      </p>
<p>于下个月和徐先森开启在一起的第4个年岁。不知从什么时候开始，我已不再怀有恋爱中的女生最大的痛苦，习惯了他时时刻刻表现得像只二货，却不再期待他是个懂得撩妹的绅士。尽管如此，我并不认为我俩已过了热恋期，相反地，我们比以前更依恋彼此。 </p>
<p><img src="/images/lover.png" alt="alt text">     </p>
<p>当然咯，我们的爱情也曾有过波折，争吵和闹分手也曾是家常便饭。后来徐先森将其均归结为年少不懂事（谁说你现在成熟了？）。     </p>
<p>如今虽分隔两地，我们之间的交流却不会少，非常感谢徐先森成了我的小小人生导师，常常给我不可估的力量。当我初来天津， 在这陌生的城市里，我并不是一个人迷茫，一个人孤单，一个人压抑，一个人努力。我有徐先森，他陪着我渡过艰难的日子，给我前进的方向。所以，我是幸运的。我一直认为两个人在一起光凭“你喜欢我，恰好我也喜欢你”是不够的，必须要有相同的世界观和价值观。一方面，徐先森最近研究的哲学我虽不甚感兴趣，却也潜移默化地改变了我俩的相处模式，我觉得他越来越有责任感。我们都知道找有责任感的男朋友，然而，责任感就像“自我”一样，是很难触摸到的东西。你不能听信男生的说辞，而是要自己去看去思考。我认为坚持，对于男人而言，就是责任感。另一方面，听过最好的情话是：我想和你一起向前努力。维持恋爱关系很重要的一点是两个人必须都有足够的动力相互扶持走下去，追求更美好的生活。有一种脆弱，是怕你飞远去，怕你离我而去，更怕你永远停留在这里。徐先森现在已是社会人士，而我还在校园为学业奋战，好在我们的话题永远不断，不说从诗词歌赋到人生哲学，倒也能有两人都感兴趣的热闻。    </p>
<p>实不相瞒，我年少时期待的浪漫，是对方当众送花，看向你的嘴角时始终带着宠溺的笑……几年的恋爱期，现在的我，期待更多的，是每次见面都能有一个大大的拥抱。除了拥抱，别的都不想要。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;除了拥抱，别的都不想要&quot;&gt;&lt;a href=&quot;#除了拥抱，别的都不想要&quot; class=&quot;headerlink&quot; title=&quot;除了拥抱，别的都不想要&quot;&gt;&lt;/a&gt;除了拥抱，别的都不想要&lt;/h2&gt;&lt;h6 id=&quot;谢谢你，仿佛迷雾星辰，深海灯塔，温暖我整个漫长冬夜。&quot;&gt;&lt;a href=&quot;#谢谢你，仿佛迷雾星辰，深海灯塔，温暖我整个漫长冬夜。&quot; class=&quot;headerlink&quot; title=&quot;谢谢你，仿佛迷雾星辰，深海灯塔，温暖我整个漫长冬夜。&quot;&gt;&lt;/a&gt;谢谢你，仿佛迷雾星辰，深海灯塔，温暖我整个漫长冬夜。&lt;/h6&gt;&lt;p&gt;从某种意义上来说，这是一份内心独白。
    
    </summary>
    
      <category term="麦加响当当" scheme="http://xuyajun.cn/categories/%E9%BA%A6%E5%8A%A0%E5%93%8D%E5%BD%93%E5%BD%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-beans（annotation）</title>
    <link href="http://xuyajun.cn/2016/10/23/Spring-beans%EF%BC%88annotation%EF%BC%89/"/>
    <id>http://xuyajun.cn/2016/10/23/Spring-beans（annotation）/</id>
    <published>2016-10-23T13:06:51.000Z</published>
    <updated>2016-12-18T07:06:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然在开始读源码之前就预料到会有很多障碍，但没想到障碍几乎无时不在。上篇对 bean 的解读就很吃力，写出来的也是让自己不满意的结果。这篇分析注解时，也是花费了一些时间才掌握了一些皮毛，很难驾驭整个思想和实现流程。忍不住去看了下《 spring 源码深度解析》，发现作者的分析解读要深刻和详细的多，让我顿时有看不下去，写不下去的顿挫感。还好，我等猿类一向喜欢挑战，自我鞭策。继续照着自己思路和水平写下去，看经典源码和看好书一样，岂能一遍就止。相信自己第二次，第三次读源码的时候，看到的是更加美丽的风景～<br><a id="more"></a></p>
<h1 id="注解三步走"><a href="#注解三步走" class="headerlink" title="注解三步走"></a>注解三步走</h1><p>先回顾下 java 自定义注解的实现过程，有三个组成部分：  </p>
<ol>
<li>写一个 @interface 定义一个注解，并指定 @Target，@Retention，@Documented，@Inherited</li>
<li>按照 @Target 的范围，在类中用上自定义的注解</li>
<li>使用反射技术来解析 java 类的注解，并做处理</li>
</ol>
<p>ok，进入正题。beans 中定义的注解有 Autowired,Qualifier,Configurable,Required,Value。这里 Autowired 最为关键和具有代表性。</p>
<h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><p>@Autowired 的定义很简单，直接来看下对应处理类 AutowiredAnnotationBeanPostProcessor 的类图：<img src="/images/AutowiredAnnotationBeanPostProcessor.png" alt="alt text"></p>
<ul>
<li>BeanPostProcessor：定义了 postProcessBeforeInitialization 和 postProcessAfterInitialization两个方法，用来对实例 bean 之前和之后做逻辑处理。</li>
<li>InstantiationAwareBeanPostProcessor：该接口是 BeanPostProcessor 的子接口，postProcessBeforeInstantiation 方法用于阻止制定 bean 的实例化，用于懒加载等情况。postProcessPropertyValues 方法用于返回给定属性值的 bean。 </li>
<li>SmartInstantiationAwareBeanPostProcessor：  InstantiationAwareBeanPostProcessor的子接口。定义了三个方法，用来获取  bean 的构造方法，bean 的类型和引用。（这种一层一层的接口在源码中太多了，体现了单一职责原则，但要理解每个接口的独特性还要去吃透每个接口方法的实现😭）</li>
<li>InstantiationAwareBeanPostProcessorAdapter：抽象类，实现了SmartInstantiationAwareBeanPostProcessor，这样子类继承这个抽象类就可以只重写感兴趣的方法，不需要去实现接口中所有方法。</li>
<li>MergedBeanDefinitionPostProcessor：定义postProcessMergedBeanDefinition 方法，用来将一个 BeanDefinition 合并到指定 bean 。</li>
<li>Aware：这个接口没有方法，只是用来标记为顶级接口，被标记的 bean 可以指定方法被 spring 框架回调。</li>
<li>BeanFactoryAware：只有 setBeanFactory 方法，为 bean 实例提供 factory。</li>
<li>Ordered：用来被需要排序，区分优先级的对象继承实现。注意：getOrder() 方法返回的值越大，优先级越小。</li>
<li>PriorityOrdered：只是继承了 Ordered 接口，无方法，用来被继承实现先确定优先对象，而不必管剩余对象。</li>
<li><p>AutowiredAnnotationBeanPostProcessor：介绍下几个重要的方法</p>
<ol>
<li>determineCandidateConstructors：查看类的构造函数是否有 @Autowired 注解，并且做了检验：被注解了的构造函数必须有参数并且最多只有一个构造函数能被设置成 required＝true。最终函数返回空或者构造函数数组。</li>
<li>buildAutowiringMetadata：对指定的 class，查找这个 class 和其superclass（一直到 superclass 为 null 止） 的所有加了 Autowired 注解的字段和方法（如果是桥接方法，需要找到原始方法），最后构造成 InjectionMetadata 对象返回。</li>
<li><p>findAutowiringMetadata：</p>
<pre><code>InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
  if (InjectionMetadata.needsRefresh(metadata, clazz)) {
     synchronized (this.injectionMetadataCache) {
        metadata = this.injectionMetadataCache.get(cacheKey);
        if (InjectionMetadata.needsRefresh(metadata, clazz)) {
           if (metadata != null) {
              metadata.clear(pvs);
           }
           metadata = buildAutowiringMetadata(clazz);
           this.injectionMetadataCache.put(cacheKey, metadata);
        }
     }
  }
</code></pre><p>双检锁（源码里很常见），这个方法调用 buildAutowiringMetadata 方法 返回 InjectionMetadata 并缓存起来。</p>
</li>
</ol>
</li>
</ul>
<h1 id="PostConstruct-amp-PreDestroy"><a href="#PostConstruct-amp-PreDestroy" class="headerlink" title="@PostConstruct &amp; @PreDestroy"></a>@PostConstruct &amp; @PreDestroy</h1><p>在 annotation 包下，除了常用的几个注解相关类外，还有一个很重要的类 InitDestroyAnnotationBeanPostProcessor 。我们都知道 InitializingBean 和 DisposableBean 的用法，但官网有句话：</p>
<blockquote>
<p>It is recommended that you do not use the InitializingBean interface because it unnecessarily couples the code to Spring.</p>
</blockquote>
<p>是的，我们更被建议使用 xml 配置或者在 java 代码里配置来实现初始化方法和销毁 bean 前钩子方法。而 InitDestroyAnnotationBeanPostProcessor 就是用来检测 bean 的这两种方法（分别被 @PostConstruct 和 @PreDestroy 注解）并使用反射调用。</p>
<p>来剖析下几个重要方法：</p>
<ol>
<li><p>buildLifecycleMetadata：对指定的 class，查找这个 class 和其superclass（一直到 superclass 为 null 止） 的所有 initAnnotationType 和 destroyAnnotationType 方法。最终返回 LifecycleMetadata 。关于initAnnotationType 和 destroyAnnotationType ，解释如下：</p>
<blockquote>
<p>Any custom annotation can be used, since there are no required annotation attributes. There is no default, although a typical choice is the JSR-250  javax.annotation.PostConstruct  and javax.annotation.PreDestroy annotation.</p>
</blockquote>
</li>
<li><p>findLifecycleMetadata：调用 buildLifecycleMetadata 方法返回 LifecycleMetadata 并缓存起来。  </p>
</li>
<li>postProcessBeforeInitialization：调用 findLifecycleMetadata 方法拿到 LifecycleMetadata 对象，并执行 invokeInitMethods ，即执行初始化方法。</li>
<li>postProcessBeforeDestruction：调用 findLifecycleMetadata 方法拿到 LifecycleMetadata 对象，并执行 invokeDestroyMethods ，即执行销毁前的钩子方法。</li>
</ol>
<p>看了这两个类后就会发现，spring 中对注解的处理方法还是比较通俗易懂。然而开始看的一段时间却是懵逼中，直到后来才有柳暗花明又一村的感觉。</p>
<p>beans 模块暂时就看到这里，我的打算是先尽快的阅读完每个模块，在脑中形成一个框架轮廓后，再进行针对的细读。嗯，读源码，我是认真的～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然在开始读源码之前就预料到会有很多障碍，但没想到障碍几乎无时不在。上篇对 bean 的解读就很吃力，写出来的也是让自己不满意的结果。这篇分析注解时，也是花费了一些时间才掌握了一些皮毛，很难驾驭整个思想和实现流程。忍不住去看了下《 spring 源码深度解析》，发现作者的分析解读要深刻和详细的多，让我顿时有看不下去，写不下去的顿挫感。还好，我等猿类一向喜欢挑战，自我鞭策。继续照着自己思路和水平写下去，看经典源码和看好书一样，岂能一遍就止。相信自己第二次，第三次读源码的时候，看到的是更加美丽的风景～&lt;br&gt;
    
    </summary>
    
      <category term="Spring源码" scheme="http://xuyajun.cn/categories/Spring%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>《javascript dom编程艺术》</title>
    <link href="http://xuyajun.cn/2016/09/30/%E3%80%8Ajavascript%20dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B/"/>
    <id>http://xuyajun.cn/2016/09/30/《javascript dom编程艺术》/</id>
    <published>2016-09-30T13:43:42.000Z</published>
    <updated>2016-09-30T13:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;很多人都认为前端的入门门槛很低，谁还没写过 html,css，js。之前自己做项目当不得不写前端的时候，随便找一个项目的前端代码，照猫画虎，发现也能迅速的实现需求。jquery，bootstrap，freemarket 都用上了。<a id="more"></a><br>&emsp;&emsp;但随着不断接触别人写的前端代码，越来越无力吐槽。几乎都有自己的风格，完全没法看。这也是为什么我在大学时期很抵触写前端的原因。还好，随着接触优秀的前端 coder，让我重拾了对前端的热情。<br>&emsp;&emsp;《 javascript dom 编程艺术》这本是我完整看的第一本前端的书籍。ps：关于学习，很多人习惯使用微信公众号来获取碎片化知识。但我本人更爱好系统的读书，掌握某一方面的知识必须要在脑中建立完整的图谱。碎片化知识做不到这点，我认为这也是为什么很多人自认为懂得很多道理却过不好生活，做不好事的原因。碎片化知识让你产生错觉，只吸收了结果，却没有去走一遍过程，你并没有掌握知识。<br>&emsp;&emsp;这本书写的很基础，但却是入门前端的绝佳书籍。除了对 js，dom 的扫盲外，更重要的是这本书会让你在一开始就树立规范意识。下面是我总结或者摘抄自原书的笔记：</p>
<ul>
<li>js是弱类型语言，不需要像java等强类型语言一样，需要指定变量的数据类型。这种设计被越来越多的语言支持，有利有弊。coder 可以更加自由的编码，一个变量可以被随意改变数据类型，但是如果稍有不慎，就会出现错误。而且这种错误只有在运行时才会知道，不像强类型语言在编译期就可以报错。</li>
<li>js 中的所有事物都是对象，比如字符串、数值、数组、函数。js 不像  java 是通过实例化类来创建对象，js 的对象基于 prototype。这本书对此没有过多讲叙，到后面我读下本书彻底理解了再总结。  </li>
<li>dom 用来解析结构化文本，比如 html／xml。浏览器会将 html 中的元素解析成 dom 树。dom 有元素节点，文本节点，属性节点三种主要节点。dom 对外提供了很多方法，用来获取或者修改节点的属性。常见的有 getElementById()，getElementByTagName()，getAttribute()，childNodes等。js 通过调用 dom 来动态对页面进行渲染。  </li>
<li><p>除了 dom core 方法，还可以使用 html-dom 提供的方法来简化。</p>
<pre><code>&gt;dom core 方法：obj.setAttribute(&quot;src&quot;,source)        
&gt;html-dom 方法：obj.src=source
</code></pre><p>  但是要注意，dom 不专属于 html 和 js，并且，html-dom 是 dom      统一浏览器之前就出现的，只适用于处理 web 文档。  </p>
</li>
<li>html 负责结构层，js 负责行为层，css 负责样式层是基础原则，之所有很多前端代码看起来困难就是因为没有很好的执行这个原则。  </li>
<li>要充分考虑用户禁用浏览器 js 的情况。</li>
</ul>
<p>&emsp;&emsp;这本书适合入门，但深度不够，想要成为专业的前端还需要更深入的去了解 js。下本准备读 js 的数据结构相关的，静候～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;很多人都认为前端的入门门槛很低，谁还没写过 html,css，js。之前自己做项目当不得不写前端的时候，随便找一个项目的前端代码，照猫画虎，发现也能迅速的实现需求。jquery，bootstrap，freemarket 都用上了。
    
    </summary>
    
      <category term="读书笔记" scheme="http://xuyajun.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-beans（bean）</title>
    <link href="http://xuyajun.cn/2016/09/24/Spring-beans%EF%BC%88bean%EF%BC%89/"/>
    <id>http://xuyajun.cn/2016/09/24/Spring-beans（bean）/</id>
    <published>2016-09-24T11:05:20.000Z</published>
    <updated>2016-10-23T13:33:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先感谢《 spring 源码深度解析》这本书，因为知道已经有前辈整理了阅读经验，让我更加能够坚持将源码进行到底。但为了达到锻炼自己最大化，我还是决定不直接去读，先按照自己的思路来。只有在不知道怎么继续下去的时候才借鉴一下前辈的经验。<br><a id="more"></a></p>
<h1 id="先做点准备工作："><a href="#先做点准备工作：" class="headerlink" title="先做点准备工作："></a>先做点准备工作：</h1><p>1.下载 spring 源码，选择的是 3.2.15 版本。<br>2.因为 spring 已经由 maven 转向 gradle,所以需要较为深刻的了解下 gradle。通过 gradle 查看依赖树，从整体上弄清每个模块的关系和功能。<br>3.gradle 编译源码遇到问题：”A problem occurred configuring project ‘：spring-orm-hibernate4’”，通过 Google，这个貌似是 3.2 版本和 gradle 版本的不兼容造成的。先不折腾，注释掉 merge.into 语句。<br>4.将源码文件夹改为只读，防止不小心修改。<br>   <code>chmod -R 555 spring-framework-3.2.15.RELEASE</code></p>
<h1 id="Bean："><a href="#Bean：" class="headerlink" title="Bean："></a>Bean：</h1><p>开始肯定是先找到一个切入类，我的做法是快速浏览一下项目的结构，熟悉每个 package 大概是什么功能。比如 Spring-beans 结构由 annotation，factory，propertyeditors，support 几个包组成，还有很多未放入包的类，不过，一看类名就知道大概是工具类和自定义的异常类。至于几个 package，annotation 里面定义了一些注解，propertyeditors 定义了数据类型之间的转换，support 提供了对 bean 排序等的一些支持功能，继续展开 factory，终于找到一个熟悉的类 XmlBeanFactory。<br>相信大家刚开始学习 spring 的时候肯定写过这行代码：<br><code>BeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));</code><br>打开发现该类已经 @Deprecated，谷歌了一下，和猜想的一样，3.1 版本已经被 applicationcontext 替换。<br><code>BeanFactory factory = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code><br>而 applicationcontext 属于 context 模块下，但还是基于 beans 模块实现的。不管，先研究下 XmlBeanFactory。</p>
<h2 id="创建-bean"><a href="#创建-bean" class="headerlink" title="创建 bean"></a>创建 bean</h2><p>用 idea 显示出 XmlBeanFactory 的类图：<img src="/images/XmlBeanFactory.png" alt="alt text"></p>
<p>ok,从 BeanFactory 入手，看看 bean 怎么被生产的，方法如图：<img src="/images/BeanFactory.png" alt="alt text">典型的工厂模式，这个就是创建 bean 的顶级工厂。<br>BeanFactory 有三个直接子类，也都是接口，初步看了一下，对应的功能分别如下：  </p>
<ul>
<li>ListableBeanFactory： 可批量创建 bean，获取 bean 信息</li>
<li>HierarchicalBeanFactory： 使 beanfactory 具有继承性</li>
<li>AutowireCapableBeanFactory： 定义了自动装配的策略  </li>
</ul>
<p>再看下类图左边的几个接口，容易理解。</p>
<ul>
<li>AliasRegistry：提供了别名管理</li>
<li>BeanDefinitionRegistry： AliasRegistry 的子接口，主要用来注册 bean</li>
<li>SimpleAliasRegistry： AliasRegistry 接口的简单实现类，使用key和value都是 String 的 map 对别名进行存储，删除等操作。  </li>
<li>SingletonBeanRegistry： 另一个顶级接口,用来注册 singleton 的 bean。</li>
</ul>
<p>类图中其他类都是由这几个接口衍生出来，但易看出，所有的接口最后都在 DefaultListableBeanFactory 类中实现。先不细看这一千多行代码，初步了解了 beanfactory 的继承图和功能就行。</p>
<h2 id="定义-bean"><a href="#定义-bean" class="headerlink" title="定义 bean"></a>定义 bean</h2><p>那接下来看啥，看 Bean 怎么被定义的。在 BeanDefinitionRegistry 中注册 bean 时，使用了 BeanDefinition。<br>找到其一个子类 RootBeanDefinition 来看看类图：<img src="/images/RootBeanDefinition.png" alt="alt text"><br>看下各个接口的功能：</p>
<ul>
<li>AttributeAccessor： 定义 bean 的属性（字段)</li>
<li>BeanMetadataElement： 只有一个 getSource() 方法，返回元数据的配置源</li>
<li>BeanDefinition： 定义了 bean 的环境属性，比如 single/prototype，是否懒加载</li>
<li>AttributeAccessorSupport： 提供了 AttributeAccessor 接口的简易实现，存储/删除/判断 bean 的属性（字段）</li>
<li>BeanMetadataAttributeAccessor： AttributeAccessorSupport 类的增加版，用 BeanMetadataAttribute 对象代替了Object</li>
<li>AbstractBeanDefinition：抽象类，为 GenericBeanDefinition，RootBeanDefinition，ChildBeanDefinition 三个子类抽象出公共的方法和属性</li>
<li>ChildBeanDefinition： 让 bean 拥有继承关系，拥有父 bean</li>
<li>RootBeanDefinition： 可以看作是多个具有继承关系 bean 的合成体</li>
<li>GenericBeanDefinition：2.5 版本后大部分场景下用来代替 ChildBeanDefinition和RootBeanDefinition，后两个类更倾向于使用在提前决定了继承关系的场景中，而 GenericBeanDefinition 可以动态配置继承关系</li>
</ul>
<p>关于 bean 的定义大致如此，先了解到这，来看下 bean 的解析。</p>
<h2 id="解析-bean"><a href="#解析-bean" class="headerlink" title="解析 bean"></a>解析 bean</h2><p>可以预见，内部的某个 Reader 读取 spring 配置文件，然后解析成 BeanDefinition 对象。在 XmlBeanFactory 类中发现 XmlBeanDefinitionReader，看下类图：<img src="/images/XmlBeanDefinitionReader.png" alt="alt text"></p>
<ul>
<li>AbstractBeanDefinitionReader： 抽象类，实现了 BeanDefinitionReader 接口，为 PropertiesBeanDefinitionReader 和 XmlBeanDefinitionReader 子类抽象出公共的方法和属性</li>
</ul>
<p>为了更好理解这几个类，需要了解下 spring 中内部对资源的处理，虽然是 core 模块中实现的。  </p>
<ul>
<li>InputStreamSource： 该接口只有一个 getInputStream 方法</li>
<li>Resource： 将输入流包装成资源</li>
<li>AbstractResource： 抽象类，继承 Resource 接口，进行了简单实现，不同来源的资源文件都会继承该基类进行各自的实现</li>
<li>WritableResource： 增加资源的写操作</li>
<li>AbstractFileResolvingResource： 将 url 形式的输入流转为文件引用输入流</li>
</ul>
<p>搞清楚 Resource 后，来梳理一下 bean 的解析过程（ XmlBeanDefinitionReader.loadBeanDefinitions ）：  </p>
<ol>
<li><strong>封装资源</strong>：<ul>
<li>从 XmlBeanFactory 中传到 XmlBeanDefinitionReader 类中的是 Resource 对象，先封装为 EncodedResource，指定编码</li>
</ul>
</li>
<li><strong>数据检验和准备</strong>：<ul>
<li>使用了一个 ThreadLocal 保存 EncodedResource，如果重复读取某个 xml 配置文件，会报错</li>
<li>从 EncodedResource 获取输入流，构建成 org.xml.sax.InputSource</li>
</ul>
</li>
<li><strong>真正解析 xml</strong>：<ul>
<li>获取对 XML 文件的验证模式</li>
<li>使用 DefaultDocumentLoader加载 XML 文件，得到 org.w3c.dom.Document 对象。</li>
<li>根据 Document 对象和资源注册 bean  </li>
</ul>
</li>
</ol>
<p>&emsp;&emsp;问题来了,看到个不太懂得玩意，<strong>对 XML 文件的验证模式</strong>？看了下代码，如果 XML 文件中包含“ DOCTYPE ”，则使用 DTD 进行验证，否则使用 XSD。DTD 和 XSD 有啥区别呢？简单了解下：</p>
<blockquote>
<p>DTD 和 XSD 是对 XML 文件两种不同的约束方式。Spring 在 2.0 版本后开始引入 XSD，相比 DTD，XSD 本身就是 XML 文件，能被解析和处理，具有支持名称空间，扩展性强等优点，是 DTD 的替代者。Spring 中如果使用 DTD 进行验证 XML，则必须声明：<br><code>&lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN 2.0//EN&quot;
            &quot;http://www.springframework.org/dtd/spring-beans-2.0.dtd&quot;&gt;</code></p>
</blockquote>
<p>&emsp;&emsp;关于通过 JAXP 的 dom 接口(<em>《 spring 源码深度解析》里作者说是使用 SAX 接口来解析的，需要纠正</em>)来解析 XML 文档，需要了解下 spring 实现了 ResourceEntityResolver 和 DelegatingEntityResolver 两种 EntityResolver。简单了解下 <strong>EntityResolver</strong>： </p>
<blockquote>
<p>解析一个 XML 时，需要根据开头的声明去网络下载 DTD 文件，对 XML 进行格式验证。而重写 EntityResolver 就可以指定去本地寻找 DTD 文件，避免网络操作。  </p>
</blockquote>
<p>&emsp;&emsp;重点放在注册 bean 上，由于 spring 很好的践行了单一职责设计模式，所以类的跳转很多。先来到 DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions：  </p>
<ol>
<li><p><strong>处理“ profile ”属性</strong>：</p>
<ul>
<li><p>关于 profile 属性，官方给出的例子如下：  </p>
<pre><code>&lt;beans profile=&quot;dev&quot;&gt;
    &lt;jdbc：embedded-database id=&quot;dataSource&quot;&gt;
        &lt;jdbc：script location=&quot;classpath：com/bank/config/sql/schema.sql&quot;/&gt;
        &lt;jdbc：script location=&quot;classpath：com/bank/config/sql/test-data.sql&quot;/&gt;
    &lt;/jdbc：embedded-database&gt;
&lt;/beans&gt;

&lt;beans profile=&quot;production&quot;&gt;
    &lt;jee：jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java：comp/env/jdbc/datasource&quot;/&gt;
&lt;/beans&gt;    
</code></pre><p>如果项目中使用 dev 环境下的数据源，则</p>
<pre><code>AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles(&quot;dev&quot;);
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();
</code></pre><p>所以如果配置了 profile 属性，则需要检验环境变量中的 profile 是否在配置中定义了，如果没有，则不进行下面的解析。</p>
</li>
</ul>
</li>
<li><p><strong>委托 BeanDefinitionParserDelegate 解析</strong>  </p>
<ul>
<li><p>核心代码：</p>
<pre><code>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
      if (delegate.isDefaultNamespace(root)) {
          NodeList nl = root.getChildNodes();
          for (int i = 0; i &lt; nl.getLength(); i++) {
              Node node = nl.item(i);
              if (node instanceof Element) {
                  Element ele = (Element) node;
                  if (delegate.isDefaultNamespace(ele)) {
                      parseDefaultElement(ele, delegate);
                  }
                  else {
                      delegate.parseCustomElement(ele);
                  }
              }
          }
      }
      else {
          delegate.parseCustomElement(root);
      }
  }
</code></pre></li>
</ul>
<p>可以看出，如果 dom 节点的名称空间是 spring 默认的 </p>
<blockquote>
<p>http：//www.springframework.org/schema/beans</p>
</blockquote>
<p>则直接按照默认标签解析。否则，就需要按照自定义的解析。</p>
</li>
</ol>
<p>&emsp;&emsp;关于 bean 暂时先阅读到这里，我们已经看到了核心的功能是怎么实现的。下一篇来学习下 Spring-beans 模块中的注解功能。</p>
<hr>
<p>&emsp;&emsp;对于怎么去高效的阅读源码，我仍处于摸索当中。怎么用博客去更好的记录和表达我的阅读成果，对我也是个挑战。相信在时间的积淀下，我会找到读源码的正确姿势，同时，我也将慢慢进行改进，在博客中加入时序图等更加直观的方式。👊</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先感谢《 spring 源码深度解析》这本书，因为知道已经有前辈整理了阅读经验，让我更加能够坚持将源码进行到底。但为了达到锻炼自己最大化，我还是决定不直接去读，先按照自己的思路来。只有在不知道怎么继续下去的时候才借鉴一下前辈的经验。&lt;br&gt;
    
    </summary>
    
      <category term="Spring源码" scheme="http://xuyajun.cn/categories/Spring%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>邂逅心学</title>
    <link href="http://xuyajun.cn/2016/08/31/%E9%82%82%E9%80%85%E5%BF%83%E5%AD%A6/"/>
    <id>http://xuyajun.cn/2016/08/31/邂逅心学/</id>
    <published>2016-08-31T11:23:12.000Z</published>
    <updated>2016-09-30T13:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;从来没有想过自己会有这么喜欢哲学的一天，而开启我的哲学学习之旅的是课本中曾一带而过的阳明心学。<br>&emsp;&emsp;记不清具体哪天又重新认识了心学。去年的实习时期，15年的10月份左右。当时我在杭州网易实习，租着一间独卫单间，12平米，和女友异地。那段时间学习欲望很强，激情很高。除了像往常一样的钻研技术，也会强迫自己去健身房健身。可能是因为从高中开始就没有读过文学书，看到办公室外的书架上摆着世界名著，我很欣喜的挑了几本回去看。<a id="more"></a>到11月份的时候，我看完了&lt;&lt;傲慢与偏见&gt;&gt;和&lt;&lt;基督山伯爵&gt;&gt;两本书，对&lt;&lt;基督山伯爵&gt;&gt;尤为爱不释手，“等待与希望”五个字让我感触颇深。<br>&emsp;&emsp;但是，总感觉内心少了什么，依旧浮躁，会周期性的和女友发脾气。文学的熏陶能让我心宁平静几天，但很快就散了，难道需要一直用文学作品的力量来维持？可是，又哪来这么多像&lt;&lt;基督山伯爵&gt;&gt;这样优秀的作品呢。<br>&emsp;&emsp;我开始明白，我此时缺少的是信仰。心学就这样在我需要信仰的时候走进了我的生活。很快，不满足于看粗略介绍阳明先生和心学的我开始抱着好奇直接阅读心学著作&lt;&lt;传习录&gt;&gt;。一开始，看着通篇的文言文，产生过退缩念头，想直接读白话版的。但是，一想到只有看原著，才能理解其原汁原味的思想和哲学，我坚持了下来。还好，不是想象中的那么晦涩难懂。刚好临近双11，在双11那天，我在淘宝上买了本&lt;&lt;王阳明最神奇的心学&gt;&gt;。此时，对心学并不算热忱，只是了解阶段。<br>&emsp;&emsp;到了11月中旬，实习离职回到了学校。转正没有成功，让我很是受打击和郁闷。一直自信的我只能感叹自己还有很多问题，不仅是技术，更是社会经验。回到学校，本以为和女友重逢能让我稍微缓解一下郁闷。但没想到很快就分手了（过程略过zzz），此时的我，感觉到了这么多年最大的挫败感。失业失恋，身边的朋友都还在外面实习，我一个人郁闷到了极点。每天在宿舍无法宣泄，内心痛苦，深夜更是无法入眠。<br>&emsp;&emsp;终于，我想起了数日没有学习了的心学。开始渴望从中寻求人生幸福真理的我比之前更加认真的学习&lt;&lt;传习录&gt;&gt;，每天晚上也只有听着喜马拉雅的”知行合一王阳明“才能入睡。慢慢的，内心开始变得平静，想到阳明先生在龙场那么恶劣的环境，实现了突破，留下了龙场悟道的佳话，越发觉得自己目前的困境根本不值一提。经常有人说，我们知道那么多道理，为什么还不能活的好。但你真的懂得那些道理吗，只能算是听过吧。知行合一，我们都知道消极不能解决问题，要积极向上，可是当我们遇到事情的时候，还是任由自己消极，这算是知道这个道理吗？不能去做的道理都不能算是知。<br>&emsp;&emsp;时光荏苒，已经是16年的九月份了，这大半年来，虽没有参悟完全心学，但是，已经足够让我内心平静。找到份满意的工作，把女友追回，爱上了哲学。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;从来没有想过自己会有这么喜欢哲学的一天，而开启我的哲学学习之旅的是课本中曾一带而过的阳明心学。&lt;br&gt;&amp;emsp;&amp;emsp;记不清具体哪天又重新认识了心学。去年的实习时期，15年的10月份左右。当时我在杭州网易实习，租着一间独卫单间，12平米，和女友异地。那段时间学习欲望很强，激情很高。除了像往常一样的钻研技术，也会强迫自己去健身房健身。可能是因为从高中开始就没有读过文学书，看到办公室外的书架上摆着世界名著，我很欣喜的挑了几本回去看。
    
    </summary>
    
      <category term="哲学" scheme="http://xuyajun.cn/categories/%E5%93%B2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>关于写博客的心路历程</title>
    <link href="http://xuyajun.cn/2016/08/28/%E5%85%B3%E4%BA%8E%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    <id>http://xuyajun.cn/2016/08/28/关于写博客的心路历程/</id>
    <published>2016-08-28T14:23:12.000Z</published>
    <updated>2016-09-29T13:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="取个题目都好难"><a href="#取个题目都好难" class="headerlink" title="取个题目都好难"></a>取个题目都好难</h2><p>&emsp;&emsp;许久没写字，当手放在键盘上，不是为了敲代码，聊天，而是为了写文章，却发现码字速率骤降，几分钟憋不出一句话。就拿这篇博客题目来说，我想扯下自己写博客的思想斗争，于是很自然的写上“关于写博客的心历路程”这个题目，但是写完之后总感觉怪怪的，心历路程？是这个词语吗？于是又很自然的搜索了一把，果然，应该是“心路历程”。😓</p>
<h2 id="为嘛写博客"><a href="#为嘛写博客" class="headerlink" title="为嘛写博客"></a>为嘛写博客</h2><a id="more"></a>
<h3 id="文笔"><a href="#文笔" class="headerlink" title="文笔"></a>文笔</h3><p>&emsp;&emsp;虽然爱看书和文笔好没有也不需要有必然的关系，但是当你看到文字的力量后，你不想掌握这种力量吗？</p>
<h3 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h3><p>&emsp;&emsp;你说你热爱技术，喜欢看哲学家吵架，但是好记性不如烂笔头。你连为它敲敲键盘都不愿意，凭什么说爱它？所以，年轻人，留下点以后能让自己和他人回忆的东西吧。</p>
<h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h3><p>&emsp;&emsp;上面都是自己找的精神层面的忽悠理由，但是感觉仍少了什么。我虽推崇当代人去追求精神建设，但是那是因为当代人已经过多的追求物质了。所以，物质也是必不可少。为了进一步忽悠自己，给博客开通了打赏功能，强行鼓励自己“只要博客写得好，就会成为Slash青年”。</p>
<h2 id="博客规划"><a href="#博客规划" class="headerlink" title="博客规划"></a>博客规划</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>&emsp;&emsp;技术毕竟是老本行，很庆幸自己能从事自己最感兴趣的职业。为了让自己时刻保持竞争力，将对当下最火的开源项目进行源码分析，学习其设计思想和编码风格。提上分析日程的项目是：spring，tomcat，kafka，diamond。之前已经或多或少的看过其源码，但没有从系统架构层面上去欣赏。希望自己能坚持，莫求写出最有深度的源码分析，但行爱好之事。</p>
<h3 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h3><p>&emsp;&emsp;哲学家大多需要满足两个条件，一个是钱多，不必为生计烦恼，闲的蛋疼，另一个是智商高，思考普通的问题没法满足自己，就整天折腾那些形而上学的问题。当然，我一个条件都沾不上边，但并不妨碍我看热闹啊，哲学家之间的唇枪舌剑还是挺有意思。虽然看起来对工作，对物质提升没有任何作用，但是你敢说自己没有在夜晚或是看着星空，或是在黑暗中问自己“人活着是为了什么”这种问题？我不提倡也不希望自己过度迷恋某种信仰，变成某个宗教的信徒，但是如果选择某种哲学思想，赋予时代意义，作为自己的人生哲学，找到自己的人生意义，那必然是受益终生。</p>
<h3 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h3><p>&emsp;&emsp;很庆幸滨江图书馆就在身边，技术，哲学，经济，国学等应有尽有。每个周末总会抽一天来这里度过，忘却繁华，品味书香。读技术书，提升专业技能；读哲学，健全人生价值观；读经济学，洞察时下社会；读国学，传承五千年文化。读过的每本书可能无法写出深刻体会或加以拓展，但随着不断借助巨人的肩膀，必然能看到高处不同的风景并留下自己的脚印。</p>
<h3 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h3><p>&emsp;&emsp;我不想把这个小站定位成技术博客站，我希望把它打理成像自己的内心世界一样丰富多彩。这也是我坚持写字的最大动力。人是最魔性的动物，一想到每个人都有其自己的故事和独特思想，就觉得很有趣不是吗。总之，无论是吐槽，还是一时兴起，只要有意义，我都会写下来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;取个题目都好难&quot;&gt;&lt;a href=&quot;#取个题目都好难&quot; class=&quot;headerlink&quot; title=&quot;取个题目都好难&quot;&gt;&lt;/a&gt;取个题目都好难&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;许久没写字，当手放在键盘上，不是为了敲代码，聊天，而是为了写文章，却发现码字速率骤降，几分钟憋不出一句话。就拿这篇博客题目来说，我想扯下自己写博客的思想斗争，于是很自然的写上“关于写博客的心历路程”这个题目，但是写完之后总感觉怪怪的，心历路程？是这个词语吗？于是又很自然的搜索了一把，果然，应该是“心路历程”。😓&lt;/p&gt;
&lt;h2 id=&quot;为嘛写博客&quot;&gt;&lt;a href=&quot;#为嘛写博客&quot; class=&quot;headerlink&quot; title=&quot;为嘛写博客&quot;&gt;&lt;/a&gt;为嘛写博客&lt;/h2&gt;
    
    </summary>
    
      <category term="扯淡" scheme="http://xuyajun.cn/categories/%E6%89%AF%E6%B7%A1/"/>
    
    
  </entry>
  
</feed>
